---
title: キャストと変換
description: さまざまなプリミティブF#型間の算術変換のための変換演算子をプログラミング言語がどのように提供するかについて説明します。
ms.date: 02/20/2020
ms.openlocfilehash: 5f9727d14a7ae070e0f0f71fa0a0abe04f662071
ms.sourcegitcommit: 771c554c84ba38cbd4ac0578324ec4cfc979cf2e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/21/2020
ms.locfileid: "77543587"
---
# <a name="casting-and-conversions-f"></a>キャストと変換 (F#)

このトピックでは、でF#の型変換のサポートについて説明します。

## <a name="arithmetic-types"></a>算術型

F#整数型と浮動小数点型の間など、さまざまなプリミティブ型間の算術変換のための変換演算子を提供します。 整数および文字の変換演算子は、チェックされたフォームと unchecked 形式を持っています。浮動小数点演算子と `enum` 変換演算子にはありません。 オフになっているフォームは `Microsoft.FSharp.Core.Operators` で定義され、チェックされたフォームは `Microsoft.FSharp.Core.Operators.Checked`で定義されます。 結果の値が対象の型の制限を超えた場合に、チェックされたフォームがオーバーフローをチェックし、ランタイム例外を生成します。

これらの各演算子には、変換先の型の名前と同じ名前が付けられています。 たとえば、次のコードでは、型に明示的に注釈が付けられているため、`byte` は2つの異なる意味で表示されます。 最初の出現は型で、2番目は変換演算子です。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4401.fs)]

次の表に、でF#定義されている変換演算子を示します。

|演算子|説明|
|--------|-----------|
|`byte`|8ビットの符号なしの型である byte に変換します。|
|`sbyte`|符号付きバイトに変換します。|
|`int16`|16ビット符号付き整数に変換します。|
|`uint16`|16ビット符号なし整数に変換します。|
|`int32, int`|32ビット符号付き整数に変換します。|
|`uint32`|32ビット符号なし整数に変換します。|
|`int64`|64ビット符号付き整数に変換します。|
|`uint64`|64ビット符号なし整数に変換します。|
|`nativeint`|ネイティブの整数に変換します。|
|`unativeint`|符号なしのネイティブ整数に変換します。|
|`float, double`|64ビットの倍精度 IEEE 浮動小数点数に変換します。|
|`float32, single`|32ビットの単精度 IEEE 浮動小数点数に変換します。|
|`decimal`|`System.Decimal`に変換します。|
|`char`|Unicode 文字 `System.Char`に変換します。|
|`enum`|列挙型に変換します。|

これらの演算子は、組み込みのプリミティブ型に加えて、適切なシグネチャを持つ `op_Explicit` または `op_Implicit` メソッドを実装する型で使用できます。 たとえば、`int` 変換演算子は、型をパラメーターとして受け取り、`int`を返す静的メソッド `op_Explicit` を提供する任意の型で動作します。 メソッドが戻り値の型によってオーバーロードできないという一般的な規則に対する特別な例外として、`op_Explicit` と `op_Implicit`に対してこれを行うことができます。

## <a name="enumerated-types"></a>列挙型

`enum` 演算子は、変換先の `enum` の型を表す1つの型パラメーターを受け取る汎用演算子です。 列挙型に変換すると、型推論は、変換先の `enum` の型を決定しようとします。 次の例では、変数 `col1` に明示的に注釈が付けられていませんが、その型は後の等値テストから推論されます。 したがって、コンパイラは、`Color` 列挙型に変換していることを推測できます。 または、次の例の `col2` のように、型の注釈を指定することもできます。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4402.fs)]

次のコードのように、ターゲットの列挙型を明示的に型パラメーターとして指定することもできます。

```fsharp
let col3 = enum<Color> 3
```

列挙キャストは、列挙型の基になる型が変換される型と互換性がある場合にのみ機能します。 次のコードでは、`int32` と `uint32`が一致しないため、変換に失敗します。

```fsharp
// Error: types are incompatible
let col4 : Color = enum 2u
```

詳細については、「[列挙型](enumerations.md)」を参照してください。

## <a name="casting-object-types"></a>キャスト (オブジェクト型を)

オブジェクト階層内の型間の変換は、オブジェクト指向プログラミングの基本となります。 変換には、キャスト (キャスト) とキャストダウン (ダウンキャスト) の2つの基本的な種類があります。 階層をキャストすることは、派生オブジェクト参照からベースオブジェクト参照へのキャストを意味します。 このようなキャストは、基底クラスが派生クラスの継承階層内にある限り、確実に動作します。 基底オブジェクト参照から派生オブジェクト参照への階層のキャストは、オブジェクトが実際には正しい宛先 (派生) 型のインスタンスであるか、または変換先の型から派生した型である場合にのみ成功します。

F#は、これらの種類の変換のための演算子を提供します。 `:>` 演算子は階層をキャストし、`:?>` 演算子は階層を下位にキャストします。

### <a name="upcasting"></a>キャスト

多くのオブジェクト指向言語では、キャストは暗黙的です。でF#は、ルールが若干異なります。 キャストは、オブジェクト型のメソッドに引数を渡すときに自動的に適用されます。 ただし、モジュール内の let バインド関数の場合、パラメーターの型が柔軟な型として宣言されていない限り、キャストは自動ではありません。 詳細については、「[柔軟な型](flexible-Types.md)」を参照してください。

`:>` 演算子は静的なキャストを実行します。これは、キャストの成功がコンパイル時に決定されることを意味します。 `:>` を使用するキャストが正常にコンパイルされた場合、それは有効なキャストであり、実行時に失敗する可能性はありません。

また、`upcast` 演算子を使用して、このような変換を実行することもできます。 次の式では、階層の上位変換が指定されています。

```fsharp
upcast expression
```

アップキャスト演算子を使用すると、コンパイラはコンテキストから変換先の型を推論しようとします。 コンパイラがターゲットの型を判断できない場合、コンパイラはエラーを報告します。 型の注釈が必要な可能性があります。

### <a name="downcasting"></a>ダウンキャスト

`:?>` 演算子は動的キャストを実行します。これは、キャストの成功が実行時に決定されることを意味します。 `:?>` 演算子を使用するキャストは、コンパイル時にはチェックされません。ただし、実行時には、指定された型にキャストしようとしました。 オブジェクトがターゲット型と互換性がある場合、キャストは成功します。 オブジェクトがターゲット型と互換性がない場合、ランタイムは `InvalidCastException`を発生させます。

`downcast` 演算子を使用して、動的な型変換を実行することもできます。 次の式は、階層の下位への変換を、プログラムコンテキストから推論される型に指定します。

```fsharp
downcast expression
```

`upcast` 演算子と同様に、コンパイラがコンテキストから特定のターゲット型を推論できない場合は、エラーが報告されます。 型の注釈が必要な可能性があります。

次のコードは、`:>` 演算子と `:?>` 演算子の使用方法を示しています。 このコードは、変換が成功することがわかっている場合に `:?>` 演算子が最適に使用されることを示しています。変換に失敗した場合は `InvalidCastException` がスローされるためです。 変換が成功したことがわからない場合は、例外を生成するオーバーヘッドを回避するため、`match` 式を使用する型テストの方が適しています。

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet4403.fs)]

ジェネリック演算子 `downcast` と `upcast` は型の推定に依存して引数と戻り値の型を決定するため、上記のコードでは、

```fsharp
let base1 = d1 :> Base1
```

with

```fsharp
let base1: Base1 = upcast d1
```

型の注釈が必要であることに注意してください。これは `upcast` 自体が基底クラスを特定できなかったためです。

## <a name="see-also"></a>参照

- [F# 言語リファレンス](index.md)
