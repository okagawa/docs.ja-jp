---
title: F# の関数型プログラミングの概要
description: でF#の関数型プログラミングの基本について説明します。
ms.date: 10/29/2018
ms.openlocfilehash: e1a0edc61dbe13012c48e166d490e22ebc70d6a0
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/01/2019
ms.locfileid: "73424712"
---
# <a name="introduction-to-functional-programming-in-f"></a>F\# での関数型プログラミングの概要

関数型プログラミングは、関数と不変データの使用を重視するプログラミングのスタイルです。 型指定された関数型プログラミングは、関数型プログラミングが、などF#の静的な型と結合される場合に使用します。 一般に、関数型プログラミングでは次の概念が強調されています。

* 使用する主なコンストラクトとしての関数
* ステートメントではなく式
* 変数に対する不変値
* 命令型プログラミングに対する宣言型プログラミング

このシリーズでは、を使用して関数型プログラミングの概念F#とパターンについて説明します。 その過程でも学習F#します。

## <a name="terminology"></a>用語

他のプログラミングパラダイムと同様に関数型プログラミングには、最終的に学習する必要があるボキャブラリが付属しています。 ここでは、すべての一般的な用語について説明します。

* **関数** - 関数とは指定した入力から出力を生成する構成要素です。 正式には、ある集合を別の集合へ _マッピング_ するものです。この定式化は様々な方法に適用されます。 特にデータのコレクションを操作する関数を扱うような場合に有効です。 これは、関数型プログラミングで最も基本的な (かつ重要な) 概念です。
* **式** - 式は、値を生成するコード要素です。 F#では、この値はバインドされるかまたは明示的に無視されます。 式は、関数呼び出しで簡単に置き換える事ができます。
* **純粋性** - 純粋性とは同じ引数に対して戻り値は常に同じであり、その評価には副作用がないという関数の性質です。 純粋関数はその引数に完全に依存します。
* **参照透過性** - 参照透過性とはプログラムの動作に影響を与えずにその出力を交換できるような式の性質です。
* **不変性** - 不変性とは、値をその場で変更できないことを意味します。 これは、その場で変化する可能性のある変数とは対照的です。

## <a name="examples"></a>使用例

次の例は、これらの主要な概念を示しています。

### <a name="functions"></a>関数

関数型プログラミングの最も一般的で基本的な構成要素は、関数です。 次に示すのは、整数に1を加算する単純な関数です。

```fsharp
let addOne x = x + 1
```

その型シグネチャは次の通りです。

```fsharp
val addOne: x:int -> int
```

署名は、"`x` という名前の `int` を受け取り、`int`を生成する" として読み取ることができ`addOne` ます。 より正式には、整数のセットの値を整数のセットに_マップ_する `addOne` ます。 `->` トークンはこのマッピングを意味します。 でF#は、通常、関数のシグネチャを調べて、その動作についての理解を得ることができます。

では、なぜ署名が重要なのでしょうか。 型指定された関数型プログラミングでは、多くの場合、関数の実装は実際の型シグネチャよりも重要度が低くなります。 値1を整数に追加 `addOne` と、実行時には興味深いことになりますが、プログラムを構築するときには、この関数を実際に使用する方法を通知するために、`int` を受け入れることになります。 さらに、(型シグネチャに関して) この関数を正しく使用すると、問題の診断は `addOne` 関数の本体内でのみ実行できます。 これは、型指定された関数型プログラミングの背後にある望むです。

### <a name="expressions"></a>式

式は、値に評価されるコンストラクトです。 アクションを実行するステートメントとは対照的に、式は値を返すアクションを実行すると考えることができます。 式は、関数型プログラミングのステートメントを優先するためにほとんど常に使用されます。

前の関数 `addOne`を考えてみます。 `addOne` の本体は式です。

```fsharp
// 'x + 1' is an expression!
let addOne x = x + 1
```

これは、`addOne` 関数の結果の型を定義する、この式の結果です。 たとえば、この関数を構成する式を、`string`などの別の型に変更することができます。

```fsharp
let addOne x = x.ToString() + "1"
```

関数のシグネチャは次のようになります。

```fsharp
val addOne: x:'a -> string
```

のF#型には `ToString()` を呼び出すことができるため、`x` の型はジェネリック ([自動汎](../language-reference/generics/automatic-generalization.md)化と呼ばれます) になり、結果の型は `string`になります。

式は関数本体だけにあるものではありません。 他の場所で使用する値を生成する式を作成できます。 一般的なものは `if`次のとおりです。

```fsharp
// Checks if 'x' is odd by using the mod operator
let isOdd x = x % 2 <> 0

let addOneIfOdd input =
    let result =
        if isOdd input then
            input + 1
        else
            input

    result
```

`if` 式では `result`という値が生成されます。 `result` を完全に省略し、`if` 式を `addOneIfOdd` 関数の本体にすることができることに注意してください。 式について覚えておくべき重要な点は、値を生成することです。

返されるものがない場合に使用される特殊な型 `unit`があります。 たとえば、次の単純な関数を考えてみます。

```fsharp
let printString (str: string) =
    printfn "String is: %s" str
```

署名は次のようになります。

```fsharp
val printString: str:string -> unit
```

`unit` 型は、返される実際の値がないことを示します。 これは、その作業の結果として返す値がない場合でも、"処理を行う必要がある" ルーチンがある場合に便利です。

これは、命令型プログラミングとは対照的です。これは、同等の `if` コンストラクトがステートメントであり、多くの場合、変数の変化によって値を生成することです。 たとえば、でC#は、次のようなコードが記述されている可能性があります。

```csharp
bool IsOdd(int x) => x % 2 != 0;

int AddOneIfOdd(int input)
{
    var result = input;

    if (IsOdd(input))
    {
        result = input + 1;
    }

    return result;
}
```

また、他の C C#スタイルの言語では、式ベースの条件付きプログラミングを可能にする[三項式](../../csharp/language-reference/operators/conditional-operator.md)がサポートされていることに注意してください。

関数型プログラミングでは、ステートメントを使用して値を変化させることはめったにありません。 一部の機能言語では、ステートメントと変異がサポートされていますが、関数型プログラミングでこれらの概念を使用するのは一般的ではありません。

### <a name="pure-functions"></a>純粋関数

前述のように、純粋関数は次のような機能を備えています。

* 同じ入力に対して常に同じ値に評価されます。
* 副作用はありません。

このコンテキストでは、数学関数を考えると便利です。 数学では、関数は引数だけに依存しており、副作用はありません。 数学関数 `f(x) = x + 1`では、`f(x)` の値は `x`の値にのみ依存します。 関数型プログラミングの純粋関数は同じように機能します。

純粋関数を記述する場合、関数はその引数にのみ依存し、副作用が発生するアクションを実行しないようにする必要があります。

次に、非純粋関数の例を示します。これは、グローバルで変更可能な状態に依存しているためです。

```fsharp
let mutable value = 1

let addOneToValue x = x + value
```

`addOneToValue` 関数は明確に純粋でないます。 `value` は、いつでも1以外の値に変更できます。 グローバル値に応じたこのパターンは、関数型プログラミングでは回避することをお勧めします。

次に、非純粋関数のもう1つの例を示します。副作用が実行されるためです。

```fsharp
let addOneToValue x =
    printfn "x is %d" x
    x + 1
```

この関数はグローバル値に依存しませんが、`x` の値をプログラムの出力に書き込みます。 これを行うには本質的に問題はありませんが、関数が純粋でないことを意味します。 プログラムの別の部分が、出力バッファーなどのプログラムの外部に依存している場合、この関数を呼び出すと、プログラムの他の部分に影響を与える可能性があります。

`printfn` ステートメントを削除すると、関数が純粋になります。

```fsharp
let addOneToValue x = x + 1
```

この関数は、`printfn` ステートメントを使用した以前のバージョンよりも本質的に_優れ_ているわけではありませんが、この関数がすべての値を返すことを保証します。 この関数を何度も呼び出すと、同じ結果が生成されます。値が生成されるだけです。 純度によって得られる予測可能性は、多くの機能プログラマが追求しています。

### <a name="immutability"></a>不変性

最後に、型指定された関数型プログラミングの最も基本的な概念の1つは不変です。 でF#は、既定ですべての値が不変です。 つまり、明示的に変更可能としてマークしない限り、これらの変換をインプレースで行うことはできません。

実際には、変更できない値を使用することは、"何かを変更する必要があります"、"新しい値を生成する必要があります" のようにプログラミングにアプローチを変更することを意味します。

たとえば、値に1を追加すると、新しい値が生成され、既存の値が変更されることはありません。

```fsharp
let value = 1
let secondValue = value + 1
```

でF#は、次のコードは `value` 関数を変化**させません**。代わりに、等価性のチェックが実行されます。

```fsharp
let value = 1
value = value + 1 // Produces a 'bool' value!
```

一部の関数型プログラミング言語では、変化を一切サポートしていません。 でF#はサポートされていますが、値の既定の動作ではありません。

この概念は、さらにデータ構造に拡張されます。 関数型プログラミング言語では、集合 (およびその他のデータ) といった不変データ構造の実装は、最初の予想とは異なります。 たとえば、セットに項目を追加しても、セットを変更しないと、_新しい_セットが生成され、値が追加されます。 内部的には、これは多くの場合、データの適切な表現を結果として得られるように、値を効率的に追跡できるようにする別のデータ構造によって実現されます。

値とデータ構造体を操作するこのスタイルは、新しいバージョンを作成する場合と同様に変更する操作を強制するため、非常に重要です。 これにより、プログラムで等価性や比較可能性などを一貫して扱う事ができます。

## <a name="next-steps"></a>次のステップ

次のセクションでは、関数を徹底的に取り上げ、関数型プログラミングにおける様々な扱い方を探ります。

[ファーストクラス関数](first-class-functions.md)は関数を深く様々なコンテキストで使用する方法を示します。

## <a name="further-reading"></a>関連項目

[Thinking Functionally](https://fsharpforfunandprofit.com/posts/thinking-functionally-intro/) シリーズは、F# を使用した関数型プログラミングについて学ぶためのもう一つの優れたリソースです。 機能を使用してF#概念を説明する、実用的で読みやすい方法での関数型プログラミングの基礎について説明します。
