---
title: 分散データ
description: モノリシックアプリケーションとクラウドネイティブアプリケーションのデータストレージを比較します。
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: 28513f8691c06cf58ed14d57bf7830bb35d94852
ms.sourcegitcommit: ee5b798427f81237a3c23d1fd81fff7fdc21e8d3
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/28/2020
ms.locfileid: "84144397"
---
# <a name="distributed-data"></a>分散データ

このブック全体で説明したように、クラウドネイティブアプローチは、アプリケーションの設計、展開、および管理の方法を変更します。 また、データの管理と保存の方法も変わります。

図5-1 は、違いを比較したものです。

![クラウドネイティブアプリケーションのデータストレージ](./media/distributed-data.png)

**図 5-1**. クラウドネイティブアプリケーションでのデータ管理

経験豊富な開発者は、図5-1 の左側のアーキテクチャを簡単に認識できます。 この*モノリシックアプリケーション*では、ビジネスサービスコンポーネントは、1つのリレーショナルデータベースのデータを共有する共有サービス層に併置します。

多くの点で、1つのデータベースはデータ管理をシンプルに維持します。 複数のテーブル間でのデータのクエリは簡単です。 データ更新の変更またはすべてのロールバック [ACID トランザクション](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties)は、厳密かつ迅速な一貫性を保証します。

クラウドネイティブの設計では、別のアプローチを採用しています。 図5-1 の右側では、ビジネス機能が小規模で独立したマイクロサービスに分離になっていることに注意してください。 各マイクロサービスは、特定のビジネス機能とその独自のデータをカプセル化します。 モノリシックデータベースは、それぞれがマイクロサービスに合わせて、多数の小さなデータベースを含む分散データモデルに分解されます。 スモークがクリアされると、*マイクロサービスごとにデータベース*を公開する設計が登場します。

## <a name="database-per-microservice-why"></a>マイクロサービスごとのデータベース、その理由

マイクロサービスごとのこのデータベースには、特に、急速に進化して大規模なスケールをサポートする必要があるシステムに関して、多くのメリットがあります。 このモデルでは...

- ドメインデータはサービス内にカプセル化されます。
- データスキーマは、他のサービスに直接影響を与えることなく進化できます。
- 各データストアは個別にスケーリングできます。
- あるサービスでのデータストアの障害が他のサービスに直接影響することはない

また、データを分離することにより、各マイクロサービスは、ワークロード、ストレージのニーズ、および読み取り/書き込みパターンに最適に最適化されたデータストアの種類を実装できます。 選択肢としては、リレーショナル、ドキュメント、キー値、さらにはグラフベースのデータストアなどがあります。

図5-2 は、クラウドネイティブシステムの多言語永続化の原則を示しています。

![多言語データ永続化](./media/polyglot-data-persistence.png)

**図 5-2** 多言語データ永続化

前の図では、各マイクロサービスが異なる種類のデータストアをサポートしていることに注意してください。

- 製品カタログマイクロサービスは、基になるデータの豊富なリレーショナル構造に対応するためにリレーショナルデータベースを消費します。
- ショッピングカートマイクロサービスは、単純なキー値データストアをサポートする分散キャッシュを消費します。
- 注文マイクロサービスは、書き込み操作に NoSql ドキュメントデータベースを使用し、高度な非正規化キー/値ストアを使用して、大量の読み取り操作に対応します。
  
リレーショナルデータベースは、複雑なデータを含むマイクロサービスに関連していますが、NoSQL データベースでは非常に人気があります。 大規模で高可用性を実現します。 これらのスキーマを使用すると、開発者は、型指定されたデータクラスのアーキテクチャから移動したり、変更をコストのかかる時間がかかるようにしたりすることができます。 NoSQL データベースについては、この章で後ほど説明します。

 データを個別のマイクロサービスにカプセル化すると、機敏性、パフォーマンス、スケーラビリティが向上しますが、多くの課題があります。 次のセクションでは、これらの課題と、それらを克服するためのパターンとプラクティスについて説明します。  

## <a name="cross-service-queries"></a>クロスサービスクエリ

マイクロサービスは独立しており、在庫、出荷、注文などの特定の機能機能に焦点を当てていますが、多くの場合、他のマイクロサービスとの統合が必要になります。 多くの場合、統合には、データに対して別のマイクロサービスに*クエリ*を実行することが含まれます。 図5-3 は、このシナリオを示しています。

![マイクロサービス間でのクエリ](./media/cross-service-query.png)

**図 5-3** マイクロサービス間でのクエリ

前の図には、ユーザーのショッピングバスケットに項目を追加するショッピングバスケットマイクロサービスがあります。 このマイクロサービスのデータストアには、バスケットと品目のデータが含まれていますが、製品や価格のデータは保持されません。 代わりに、これらのデータ項目はカタログと料金マイクロサービスによって所有されます。 これにより、問題が発生します。 製品や価格データがデータベースに含まれていない場合、買い物かごマイクロサービスで製品をユーザーのショッピングバスケットに追加するにはどうすればよいですか。

第4章で説明されている1つのオプションは、ショッピングカートからカタログおよび料金マイクロサービスへの[直接 HTTP 呼び出し](service-to-service-communication.md#queries)です。 ただし、第4章では、 *1 つのマイクロサービス*に対して同期 HTTP 呼び出しを行っています。これにより、自律性が減少し、アーキテクチャ上のメリットが低下します。

また、各サービスに対して個別の受信キューと出力キューを使用して、要求/応答パターンを実装することもできます。 ただし、このパターンは複雑で、要求メッセージと応答メッセージを関連付けるためにプラミングが必要です。
バックエンドマイクロサービス呼び出しを分離しますが、呼び出しが完了するまで、呼び出し元のサービスは同期的に待機する必要があります。 ネットワークの輻輳、一時的なエラー、またはオーバーロードされたマイクロサービスによって、実行時間が長く、操作が失敗する可能性があります。

代わりに、図5-4 に示すように、サービス間の依存関係を削除するために広く使用されているパターンが具体化された[ビューパターン](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)となります。

![具体化ビューパターン](./media/materialized-view-pattern.png)

**図 5-4** 具体化ビューパターン

このパターンでは、買い物かごサービスにローカルデータテーブル (*読み取りモデル*と呼ばれます) を配置します。 このテーブルには、製品および料金マイクロサービスに必要なデータの非正規化されたコピーが含まれています。 ショッピングカートマイクロサービスにデータを直接コピーすることで、高価なクロスサービス呼び出しが不要になります。 サービスに対してローカルなデータを使用すると、サービスの応答時間と信頼性が向上します。 さらに、独自のデータコピーを用意することにより、買い物かごサービスの回復性が向上します。 カタログサービスが使用できなくなると、買い物かごサービスに直接影響することはありません。 ショッピングカートは、独自のストアのデータを操作し続けることができます。

このアプローチを使用すると、システム内に重複するデータが存在することになります。 ただし、クラウドネイティブシステムで*戦略的*にデータを複製することは、確立された手法であり、アンチパターンや悪い慣習とは見なされません。 1*つのサービスのみ*がデータセットを所有し、それに対する権限を持つことができることに注意してください。 レコードのシステムが更新されたときに、読み取りモデルを同期する必要があります。 同期は通常、[発行/サブスクライブパターン](service-to-service-communication.md#events)を使用した非同期メッセージングによって実装されます (図5.4 を参照)。

## <a name="distributed-transactions"></a>分散トランザクション

マイクロサービス間でデータのクエリを実行することは困難ですが、複数のマイクロサービスにトランザクションを実装することは、さらに複雑になります。 異なるマイクロサービスの独立したデータソース間でデータの一貫性を維持するための固有の課題を袖口することはできません。 クラウドネイティブアプリケーションでの分散トランザクションの欠如は、分散トランザクションをプログラムによって管理する必要があることを意味します。 *一貫性*のある世界から、*最終的な整合性*に移行します。

図5-5 は、この問題を示しています。

![Saga パターンでのトランザクション](./media/saga-transaction-operation.png)

**図 5-5** マイクロサービス間でのトランザクションの実装

前の図では、5つの独立したマイクロサービスが、注文を作成する分散トランザクションに参加しています。 各マイクロサービスは、独自のデータストアを保持し、そのストアのローカルトランザクションを実装します。 注文を作成するには *、個々のマイクロサービスのローカル*トランザクションが成功する必要があります。これを行わないと、操作を中止してロール*バックする必要があります*。 組み込みのトランザクションサポートは各マイクロサービス内で利用できますが、データの整合性を維持するために、5つのサービスすべてにわたって分散トランザクションがサポートされているわけではありません。

代わりに、この分散トランザクションを*プログラム*で構築する必要があります。

分散トランザクションサポートを追加するための一般的なパターンは、Saga パターンです。 ローカルトランザクションをプログラムによってグループ化し、それぞれを順番に呼び出すことによって実装されます。 ローカルトランザクションのいずれかが失敗した場合、Saga は操作を中止し、一連の[補正トランザクション](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)を呼び出します。 補正トランザクションは、前のローカルトランザクションによって行われた変更を元に戻し、データの整合性を復元します。 図5-6 は、Saga パターンを使用した失敗したトランザクションを示しています。

![Saga パターンでロールバックする](./media/saga-rollback-operation.png)

**図 5-6**. トランザクションのロールバック

前の図では、インベントリマイクロサービスでの*インベントリの更新*操作が失敗しました。 Saga は、補正トランザクション (赤) のセットを呼び出して、在庫数を調整し、支払いと注文を取り消し、各マイクロサービスのデータを一貫性のある状態に戻します。

Saga パターンは、通常、関連する一連のイベントとして choreographed されるか、関連する一連のコマンドとして調整されます。 4章では、調整された saga 実装の基盤となるサービスアグリゲーターパターンについて説明しました。 また、イベントと共に Azure Service Bus と、choreographed saga の実装の基礎となるトピック Azure Event Grid についても説明しました。

## <a name="high-volume-data"></a>大量のデータ

大規模なクラウドネイティブアプリケーションは、多くの場合、大量のデータ要件をサポートします。 このようなシナリオでは、従来のデータストレージ手法によってボトルネックが発生する可能性があります。 大規模な環境に配置する複雑なシステムでは、コマンドクエリ責務分離 (CQRS) とイベントソーシングの両方で、アプリケーションのパフォーマンスを向上させることができます。  

### <a name="cqrs"></a>CQRS

[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)は、パフォーマンス、スケーラビリティ、およびセキュリティを最大化するのに役立つアーキテクチャパターンです。 このパターンでは、データを書き込む操作からデータを読み取る操作を分離します。

通常のシナリオでは、同じエンティティモデルとデータリポジトリオブジェクトが読み取り操作と書き込み操作の*両方*に使用されます。

ただし、大量のデータを使用するシナリオでは、読み取りと書き込みのために個別のモデルとデータテーブルを利用できます。 パフォーマンスを向上させるために、読み取り操作では、負荷の高いテーブル結合やテーブルロックを避けるために、データの非常に非正規化された表現に対してクエリを実行できます。 *書き込み*操作は、*コマンド*と呼ばれ、一貫性を保証するデータの完全に正規化された表現に対して更新されます。 次に、両方の表現を同期させておくためのメカニズムを実装する必要があります。通常、書き込みテーブルが変更されるたびに、その変更を読み取りテーブルにレプリケートするイベントが発行されます。

図5-7 は、CQRS パターンの実装を示しています。

![コマンド クエリ責務分離](./media/cqrs-implementation.png)

**図 5-7** CQRS の実装

前の図では、個別のコマンドモデルとクエリモデルが実装されています。 各データ書き込み操作は、書き込みストアに保存され、読み取りストアに反映されます。 [最終的な整合性](https://www.cloudcomputingpatterns.org/eventual_consistency/)の原則でデータ伝達プロセスがどのように動作するかに注意してください。 読み取りモデルは、最終的に書き込みモデルと同期しますが、プロセスに遅延が発生する場合があります。 最終的な整合性については、次のセクションで説明します。

この分離により、読み取りと書き込みを個別にスケーリングできます。 読み取り操作では、クエリ用に最適化されたスキーマを使用します。書き込みでは、更新に対して最適化されたスキーマが使用されます。 読み取りクエリは非正規化されたデータに対して行われますが、複雑なビジネスロジックを書き込みモデルに適用することができます。 また、読み取りを公開するよりも書き込み操作に対してセキュリティを強化することもできます。

CQRS を実装することで、クラウドネイティブサービスのアプリケーションパフォーマンスを向上させることができます。 ただし、より複雑な設計になります。 この原則は、クラウドネイティブアプリケーションのこれらのセクションに慎重かつ戦略的に適用して、それを活用します。 CQRS の詳細については、「Microsoft book [.Net マイクロサービス: コンテナー化された .Net アプリケーションのアーキテクチャ](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)」を参照してください。

### <a name="event-sourcing"></a>イベント ソーシング

大量のデータを最適化するための別の方法として、[イベントソーシング](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)があります。

システムは通常、データエンティティの現在の状態を格納します。 たとえば、ユーザーが電話番号を変更した場合、顧客レコードは新しい番号で更新されます。 データエンティティの現在の状態は常にわかっていますが、更新ごとに前の状態が上書きされます。

ほとんどの場合、このモデルは正常に動作します。 ただし、大量のシステムでは、トランザクションロックや頻繁な更新操作のオーバーヘッドによって、データベースのパフォーマンス、応答性、スケーラビリティの制限が影響を受ける可能性があります。

イベントソーシングは、データをキャプチャするための別のアプローチを取ります。 データに影響を与える各操作は、イベントストアに保存されます。 データレコードの状態を更新する代わりに、会計士の台帳と同様に、各変更を過去のイベントの連続するリストに追加します。 イベントストアは、データのレコードのシステムになります。 これは、マイクロサービスの境界コンテキスト内で、具体化されたさまざまなビューを伝達するために使用されます。 図5.8 は、パターンを示しています。

![イベント ソーシング](./media/event-sourcing.png)

**図 5-8**. イベント ソーシング

前の図では、ユーザーのショッピングカートの各エントリ (blue) が、基になるイベントストアに追加されていることに注意してください。 隣接する具体化されたビューでは、各ショッピングカートに関連付けられているすべてのイベントを再生することにより、現在の状態がプロジェクトによって射影されます。 このビューまたは読み取りモデルは、UI に再び表示されます。 イベントは、外部のシステムやアプリケーションと統合したり、クエリを実行してエンティティの現在の状態を確認したりすることもできます。 この方法では、履歴を保持します。 エンティティの現在の状態だけでなく、この状態に到達したこともわかっています。

機械的は、イベントソーシングは書き込みモデルを簡略化します。 更新または削除はありません。 各データエントリを不変イベントとして追加すると、リレーショナルデータベースに関連付けられている競合、ロック、および同時実行の競合を最小限に抑えることができます。 具体化されたビューパターンを使用して読み取りモデルを構築すると、書き込みモデルからビューを切り離し、最適なデータストアを選択してアプリケーションの UI のニーズを最適化することができます。

このパターンでは、イベントソーシングを直接サポートするデータストアを考えてみます。 Azure Cosmos DB、MongoDB、Cassandra、CouchDB、RavenDB は適切な候補です。

すべてのパターンとテクノロジと同様に、必要に応じて戦略的に実装します。 イベントソーシングは、パフォーマンスとスケーラビリティを向上させることができますが、複雑さと学習曲線を犠牲にしています。

>[!div class="step-by-step"]
>[前へ](service-mesh-communication-infrastructure.md)
>[次へ](relational-vs-nosql-data.md)
