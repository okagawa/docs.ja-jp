---
title: クラウドネイティブアプリ向けの Azure セキュリティ
description: Azure 向けのクラウドネイティブ .NET アプリの設計 |クラウドネイティブアプリ向けの Azure セキュリティ
ms.date: 05/13/2020
ms.openlocfilehash: 223d9e77aca611697958981bf2ee3a630fb9fffb
ms.sourcegitcommit: e7748001b1cee80ced691d8a76ca814c0b02dd9b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/14/2020
ms.locfileid: "86374495"
---
# <a name="azure-security-for-cloud-native-apps"></a>クラウドネイティブアプリ向けの Azure セキュリティ

クラウドネイティブアプリケーションは、従来のアプリケーションよりも簡単で安全です。 欠点としては、より小さなアプリケーションを保護し、セキュリティインフラストラクチャを構築するためのエネルギーを追加する必要があります。 ほとんどのサービス展開におけるプログラミング言語とスタイルの異種の性質は、多くの異なるプロバイダーからのセキュリティ情報にさらに注意を払う必要があることを意味します。

フリップ側では、それぞれが独自のデータストアを持つ小規模なサービスによって、攻撃の範囲が制限されます。 攻撃者が1つのシステムに侵入した場合、攻撃者がモノリシックアプリケーションよりも別のシステムに移動することは、より困難になる可能性があります。 プロセスの境界は強力な境界です。 また、データベースバックアップでリークが発生した場合、そのデータベースにはデータのサブセットしか含まれていないため、個人データが含まれる可能性が低いため、損傷はより制限されます。

## <a name="threat-modeling"></a>脅威モデリング

クラウドネイティブアプリケーションの欠点を上回る場合でも、同じ総合的なセキュリティの考え方に従う必要があります。 セキュリティとセキュリティを考慮することは、開発と運用のストーリーのすべての手順に含まれている必要があります。 アプリケーションを計画するときは、次のような質問をしてください。

- このデータの損失による影響は何ですか。
- このサービスに無効なデータが挿入された場合の損害を制限するにはどうすればよいですか。
- 誰がこのデータにアクセスできる必要がありますか。
- 開発プロセスとリリースプロセスに関して、監査ポリシーは適用されていますか。

これらの質問はすべて、[脅威のモデル](https://docs.microsoft.com/azure/security/azure-security-threat-modeling-tool)化と呼ばれるプロセスに含まれています。 このプロセスでは、システムに対して発生した脅威、脅威の可能性、およびそれらの潜在的な損害についての質問に回答しようとします。

脅威の一覧が確立されたら、軽減する価値があるかどうかを判断する必要があります。 場合によっては、脅威が非常に低く、コストをかける価値がないということを計画するとコストがかかります。 たとえば、一部の状態レベルのアクターは、何百万ものデバイスによって使用されるプロセスの設計に変更を注入する場合があります。 ここで、[リング 3](https://en.wikipedia.org/wiki/Protection_ring)で特定のコードを実行する代わりに、そのコードはリング0で実行されます。 これにより、ハイパーバイザーをバイパスし、ベアメタルコンピューターで攻撃コードを実行して、そのハードウェアで実行されているすべての仮想マシンに対する攻撃を防ぐことができます。

変更されたプロセッサは、そのプロセッサのシリコン設計の microscope と高度な知識がなくても検出するのが困難です。 このシナリオはほとんど発生せず、軽減コストがかかります。そのため、脅威モデルでは、悪用防止の構築が推奨されない可能性があります。

アクセス制御の中断 `Id` (URL 内での置換) や SQL インジェクションなど、潜在的な脅威が発生した場合、それに `Id=2` `Id=3` 対する保護を構築する方が魅力的です。 これらの脅威の軽減策は、企業の評判を他人セキュリティホールを構築し、防止するのに非常に適しています。

## <a name="principle-of-least-privilege"></a>最小限の特権の原則

コンピューターのセキュリティにおける設立のアイデアの1つは、最小特権 (POLP) の原則です。 これは、ほぼすべての形式のセキュリティにおいて、デジタルまたは物理的に基本的な考え方です。 つまり、ユーザーまたはプロセスには、そのタスクを実行するための最小限の権限が与えられている必要があります。

たとえば、銀行の窓口を考えてみましょう。安全にアクセスすることは珍しいことではありません。 そのため、平均の窓口は安全なのを開けません。 アクセス権を得るには、追加のセキュリティチェックを実行する銀行マネージャーを通じて要求をエスカレートする必要があります。

コンピューターシステムですばらしい例として、データベースに接続するユーザーの権限があります。 多くの場合、データベース構造を構築してアプリケーションを実行するために使用される1つのユーザーアカウントがあります。 極端なケースを除き、アプリケーションを実行するアカウントには、スキーマ情報を更新する機能は必要ありません。 さまざまなレベルの特権を提供するいくつかのアカウントがあります。 アプリケーションでは、テーブル内のデータへの読み取りおよび書き込みアクセスを許可する権限レベルのみを使用する必要があります。 この種の保護により、データベーステーブルを削除したり、悪意のあるトリガーを導入したりする攻撃を防ぐことができます。

クラウドネイティブアプリケーションを構築するほとんどすべての部分は、最小限の特権の原則を覚えることによってメリットがあります。 ファイアウォール、ネットワークセキュリティグループ、ロール、およびスコープをロールベースのアクセス制御 (RBAC) で設定すると、再生時に確認できます。

## <a name="penetration-testing"></a>侵入テスト

アプリケーションが複雑になるにつれて、攻撃ベクトルの数は増加率で増加します。 脅威のモデル化は、システムを構築するのと同じ担当者によって実行される傾向があるため、欠点があります。 多くの開発者がユーザーとの対話を構想し、使用できないユーザーインターフェイスを構築する場合と同様に、ほとんどの開発者はすべての攻撃ベクトルを確認することが困難です。 また、システムを構築している開発者が攻撃方法論に精通しておらず、重要な問題を見逃している可能性もあります。

侵入テストまたは "ペンテスト" とは、外部アクターによるシステムの攻撃を試みることです。 これらの攻撃者は、ビジネスの別の部分からの優れたセキュリティ知識を持つ外部コンサルティング会社または他の開発者である可能性があります。 システムの破壊を試みるために、個別のれる完全が与えられます。 多くの場合、パッチを適用する必要がある広範なセキュリティホールが検出されます。 攻撃ベクトルは、CEO に対するフィッシング攻撃を悪用するように、まったく予期しないものになることがあります。

Azure 自体は、 [Microsoft 社内のハッカーチーム](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)からの攻撃を常に受けています。 長年にわたり、外部から悪用される前に、多数の致命的な攻撃ベクトルを発見し、それらを閉じることができました。 ターゲットが魅力的になるほど、永続的アクターがこれを悪用しようとし、世界中に Azure よりも魅力的なターゲットがいくつか存在する可能性が高くなります。

## <a name="monitoring"></a>監視

攻撃者がアプリケーションに侵入しようとすると、警告が発生します。 多くの場合、サービスからのログを調べることで攻撃を発見できます。 攻撃は、成功する前に、telltale の兆候が出る可能性があります。 たとえば、攻撃者がパスワードを推測しようとすると、ログインシステムに対して多くの要求が行われます。 ログインシステムを監視すると、通常のアクセスパターンでは、アウトオブラインのパターンを検出できます。 この監視は、何らかの種類の対策をアクティブ化するために、運用担当者にアラートを通知することができます。 非常に成熟した監視システムは、要求をブロックしたり応答を調整したりするための規則を事前に追加することによって、これらの偏差に基づいてアクションを実行できます

## <a name="securing-the-build"></a>ビルドをセキュリティで保護する

セキュリティが見落とされることが多い場所の1つは、ビルドプロセスです。 安全でないコードやチェックインされた資格情報のスキャンなど、ビルドでセキュリティチェックを実行するだけでなく、ビルド自体をセキュリティで保護する必要があります。 ビルドサーバーが侵害された場合は、任意のコードを製品に導入するための優れたベクターが提供されます。

攻撃者が web アプリケーションにサインインする人のパスワードを盗むことを考えているとします。 これにより、チェックアウトされたコードを変更して、任意のログイン要求を別のサーバーに反映するビルドステップを導入できます。 次回ビルドを実行すると、コードが自動的に更新されます。 ソースコードの脆弱性のスキャンでは、ビルドの前に実行されるため、これはキャッチされません。 ビルド手順がビルドサーバー上に存在するため、コードレビューでそれをキャッチすることはほとんどありません。 悪用されたコードは、パスワードを入手できる運用環境に移行します。 ビルドプロセスの変更の監査ログがないか、少なくとも監査を監視していない可能性があります。

これは、システムを中断するために使用できる、一見低い値のターゲットの完全な例です。 システムの境界が攻撃者に侵害されると、ユーザーはアクセス許可を昇格させる方法を見つけることができます。

## <a name="building-secure-code"></a>セキュリティで保護されたコードのビルド

.NET Framework は、既に非常に安全なフレームワークです。 これにより、配列の終端のウォークなど、アンマネージコードの落とし穴が回避されます。 作業は、検出されたセキュリティホールを修正するために積極的に実行されます。 [バグバウンティプログラム](https://www.microsoft.com/msrc/bounty)もあります。これは、調査担当者がフレームワークの問題を発見し、それらを活用する代わりに報告するために利用します。

.NET コードをより安全にするには、さまざまな方法があります。 [.Net 用のセキュリティで保護](../../standard/security/secure-coding-guidelines.md)されたコーディングのガイドラインなどのガイドラインに従うことは、コードが最初からセキュリティで保護されていることを確認するための合理的な手順です。 [Owasp の上位 10](https://owasp.org/www-project-top-ten/)は、セキュリティで保護されたコードを構築するための非常に有益なガイドです。

ビルドプロセスでは、運用環境に移行する前に、ソースコードの問題を検出するためにスキャンツールを配置することをお勧めします。 ほとんどのプロジェクトには、他のパッケージに依存関係があります。 古くなったパッケージをスキャンできるツールは、夜間ビルドで問題をキャッチします。 Docker イメージを構築する場合でも、基本イメージに既知の脆弱性がないことを確認して確認すると便利です。 もう1つの注意点は、資格情報が誤ってチェックインされていないことです。

## <a name="built-in-security"></a>組み込みのセキュリティ

Azure は、ほとんどのユーザーに使いやすさとセキュリティのバランスを取るように設計されています。 ユーザーごとにセキュリティ要件が異なるため、クラウドセキュリティへのアプローチを微調整する必要があります。 Microsoft は、セキュリティ[センター](https://azure.microsoft.com/support/trust-center/)で多くのセキュリティ情報を公開しています。 このリソースは、組み込みの攻撃対策テクノロジがどのように機能するかを理解している担当者の最初の停止にする必要があります。

Azure portal において、 [Azure Advisor](https://azure.microsoft.com/services/advisor/)は、常に環境をスキャンし、推奨を行うシステムです。 これらの推奨事項の一部はユーザーの費用を節約するように設計されていますが、他のユーザーは、ストレージコンテナーが世界中に開かれていて、Virtual Network によって保護されていないなど、安全でない可能性のある構成を特定するように設計さ

## <a name="azure-network-infrastructure"></a>Azure ネットワーク インフラストラクチャ

オンプレミスのデプロイ環境では、ネットワークのセットアップ専用のエネルギーが非常に多くあります。 ルーター、スイッチ、およびを設定することは、複雑な作業です。 ネットワークを使用すると、特定のリソースが他のリソースと通信し、場合によってはアクセスを防ぐことができます。 頻繁に発生するネットワークルールでは、開発環境から運用環境へのアクセスを制限します。これにより、開発環境から、半開発されたコードの一部が実行されなくなり、データのさまざまが削除されます。

既定では、ほとんどの PaaS Azure リソースには、最も基本的で制限のないネットワーク設定しかありません。 たとえば、インターネット上の誰でも app service にアクセスできます。 通常、新しい SQL Server インスタンスは制限されるため、外部のパーティがアクセスすることはできませんが、Azure 自体で使用される IP アドレス範囲はによって許可されます。 そのため、SQL server が外部の脅威から保護されている間、攻撃者は azure のブリッジヘッドを設定するだけで、Azure 上のすべての SQL インスタンスに対して攻撃を仕掛けることができます。

幸いなことに、ほとんどの Azure リソースを Azure Virtual Network に配置して、きめ細かいアクセス制御を可能にすることができます。 オンプレミスのネットワークでは、より広範囲に保護されたプライベートネットワークを確立するのと同様に、仮想ネットワークは、Azure ネットワーク内に配置されているプライベート IP アドレスの孤島です。

![図 9-1 Azure の仮想ネットワーク](./media/virtual-network.png)

**図 9-1** Azure の仮想ネットワーク。

オンプレミスネットワークにネットワークへのアクセスを制御するファイアウォールがあるのと同じように、仮想ネットワークの境界で同様のファイアウォールを確立できます。 既定では、仮想ネットワーク上のすべてのリソースがインターネットと通信できます。 これは、何らかの形式の明示的なファイアウォール例外を必要とする受信接続のみです。

ネットワークが確立されたら、ストレージアカウントなどの内部リソースが、Virtual Network にもあるリソースによってのみアクセスを許可するように設定できます。 このファイアウォールにより、セキュリティレベルが強化されます。そのストレージアカウントのキーが漏洩した場合、攻撃者は、リークしたキーを悪用するために接続できなくなります。 これは、最小特権の原則のもう1つの例です。

Azure Kubernetes クラスター内のノードは、Azure に対してネイティブな他のリソースと同じように、仮想ネットワークに参加できます。 この機能は、 [Azure Container Network インターフェイス](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)と呼ばれます。 実質的には、仮想マシンとコンテナーイメージが割り当てられている仮想ネットワーク内にサブネットを割り当てます。

最小限の特権の原則を示すパスを続行すると、Virtual Network 内のすべてのリソースが他のすべてのリソースと通信する必要がなくなります。 たとえば、ストレージアカウントと SQL データベースに対して web API を提供するアプリケーションでは、データベースとストレージアカウントが相互に通信する必要はほとんどありません。 これらの間でデータを共有すると、web アプリケーションが実行されます。 そのため、[ネットワークセキュリティグループ (NSG)](https://docs.microsoft.com/azure/virtual-network/security-overview)を使用して、2つのサービス間のトラフィックを拒否することができます。

リソース間の通信を拒否するポリシーは、特にトラフィック制限なしで Azure を使用することによって、実装するのが面倒な場合があります。 その他のクラウドでは、ネットワークセキュリティグループの概念がより一般的になっています。 たとえば、AWS の既定のポリシーは、NSG 内のルールによって有効になるまで、リソースが自身の間で通信できないということです。 この開発には時間がかかりますが、より制限の厳しい環境では、より安全な既定値が提供されます。 適切な DevOps プラクティス (特に、 [Azure Resource Manager または Terraform](infrastructure-as-code.md)を使用してアクセス許可を管理する) を使用すると、規則を簡単に制御できるようになります。

仮想ネットワークは、オンプレミスとクラウドのリソース間の通信を設定するときにも役立ちます。 仮想プライベートネットワークを使用して、2つのネットワークをシームレスに接続することができます。 これにより、すべてのユーザーがオンサイトに配置されているシナリオで、任意の種類のゲートウェイを使用せずに仮想ネットワークを実行できます。 このネットワークの確立に使用できるテクノロジは多数あります。 最も簡単なのは、多数のルーターと Azure の間に確立できる[サイト間 VPN](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#s2smulti)を使用することです。 トラフィックは、他のトラフィックと同じように、1バイトあたり同じコストで暗号化され、インターネット経由でトンネリングされます。 より多くの帯域幅またはセキュリティが望ましいシナリオでは、Azure は、オンプレミスネットワークと Azure の間でプライベート回線を使用する[expressroute](https://docs.microsoft.com/azure/vpn-gateway/vpn-gateway-about-vpngateways?toc=%2fazure%2fvirtual-network%2ftoc.json#ExpressRoute)と呼ばれるサービスを提供します。 コストが高く、より安全に確立することも困難です。

## <a name="role-based-access-control-for-restricting-access-to-azure-resources"></a>Azure リソースへのアクセスを制限するためのロールベースのアクセス制御

RBAC は、Azure で実行されているアプリケーションに id を提供するシステムです。 アプリケーションは、キーまたはパスワードの代わりに、この id を使用してリソースにアクセスできます。

## <a name="security-principals"></a>セキュリティ プリンシパル

RBAC の最初のコンポーネントはセキュリティプリンシパルです。 セキュリティプリンシパルには、ユーザー、グループ、サービスプリンシパル、または管理対象 id を指定できます。

![図9-2 さまざまな種類のセキュリティプリンシパル](./media/rbac-security-principal.png)

**図 9-2** さまざまな種類のセキュリティプリンシパル。

- ユーザー-Azure Active Directory のアカウントを持つすべてのユーザーがユーザーです。
- グループ-Azure Active Directory のユーザーのコレクション。 グループのメンバーとして、ユーザーは自身に加えて、そのグループのロールを引き継ぎます。
- サービスプリンシパル-サービスまたはアプリケーションの実行に使用するセキュリティ id。
- 管理対象 id-Azure によって管理される Azure Active Directory id。 管理対象 id は、通常、Azure サービスに対する認証用の資格情報を管理するクラウドアプリケーションを開発するときに使用されます。

セキュリティプリンシパルは、ほとんどすべてのリソースに適用できます。 これは、Azure Kubernetes 内で実行されているコンテナーにセキュリティプリンシパルを割り当てることができることを意味します。これにより、Key Vault に格納されているシークレットにアクセスできるようになります。 Azure 関数は、呼び出し元のユーザーの JWT を検証するために、Active Directory インスタンスと対話できるアクセス許可を受け取ることができます。 サービスプリンシパルを使用してサービスを有効にすると、そのアクセス許可はロールとスコープを使用して細かく管理できます。

## <a name="roles"></a>ロール

セキュリティプリンシパルは、多くの役割を果たすことができます。また、sartorial のような多くの帽子を使用することもできます。 各ロールは、"Azure Service Bus エンドポイントからメッセージを読み取る" などの一連のアクセス許可を定義します。 セキュリティプリンシパルの有効なアクセス許可セットは、セキュリティプリンシパルが持つすべてのロールに割り当てられたすべてのアクセス許可を組み合わせたものです。 Azure には多数の組み込みロールがあり、ユーザーは独自のロールを定義できます。

![図 9-3 RBAC ロールの定義](./media/rbac-role-definition.png)

**図 9-3** RBAC ロールの定義。

Azure には、所有者、共同作成者、閲覧者、ユーザーアカウント管理者などの高度なロールも多数あります。 所有者ロールを使用すると、セキュリティプリンシパルはすべてのリソースにアクセスし、他のユーザーにアクセス許可を割り当てることができます。 共同作成者は、すべてのリソースに対して同じレベルのアクセス権を持ちますが、アクセス許可を割り当てることはできません。 閲覧者は、既存の Azure リソースのみを表示できます。また、ユーザーアカウント管理者は、Azure リソースへのアクセスを管理できます。

[DNS ゾーンの共同作成者](https://docs.microsoft.com/azure/role-based-access-control/built-in-roles#dns-zone-contributor)などのより詳細な組み込みロールは、1つのサービスに限定されています。 セキュリティプリンシパルは、任意の数のロールに対して実行できます。

## <a name="scopes"></a>スコープ

ロールは、Azure 内の限られたリソースのセットに適用できます。 たとえば、Service Bus キューからの読み取りの前の例にスコープを適用すると、"Azure Service Bus エンドポイントからメッセージを読み取る" という1つのキューにアクセス許可を絞り込むことができます。 `blah.servicebus.windows.net/queue1`

スコープは、1つのリソースとして絞り込むことができます。また、リソースグループ、サブスクリプション、または管理グループ全体に適用することもできます。

セキュリティプリンシパルに特定のアクセス許可があるかどうかをテストする場合、ロールとスコープの組み合わせが考慮されます。 この組み合わせにより、強力な承認メカニズムが提供されます。

## <a name="deny"></a>拒否

以前は、RBAC で許可されているのは "許可" 規則のみでした。 この動作により、いくつかのスコープが構築に複雑になりました。 たとえば、セキュリティプリンシパルがすべてのストレージアカウントにアクセスできるようにするには、必要なストレージアカウントの一覧に対して明示的なアクセス許可を付与する必要があります。 新しいストレージアカウントが作成されるたびに、このアカウントの一覧に追加される必要があります。 これにより、管理オーバーヘッドが追加されました。

拒否ルールは許可ルールよりも優先されます。 ここでは、同じ "すべてのスコープを許可する" という同じスコープを表すことができるのは、"すべて許可" と "特定の1つの特定のものを拒否する" という2つのルールです。 拒否規則は、管理を容易にするだけでなく、すべての人へのアクセスを拒否することで、追加のセキュリティで保護されたリソースを許可します。

## <a name="checking-access"></a>アクセスの確認

ご想像のとおり、多数のロールとスコープがあると、サービスプリンシパルの有効な権限が非常に困難になる可能性があります。 積み上がり始まっは、その上に拒否ルールを適用し、複雑さを増加させるためだけに機能します。 幸い、どのサービスプリンシパルに対しても有効な権限を表示できるアクセス許可電卓があります。 通常は、図10-3 に示すように、ポータルの [IAM] タブの下にあります。

![図 9-4 app service のアクセス許可の計算](./media/check-rbac.png)

**図 9-4**. App service のアクセス許可電卓。

## <a name="securing-secrets"></a>シークレットの保護

パスワードと証明書は、攻撃者にとって一般的な攻撃ベクトルです。 パスワードをクラッキングするハードウェアは、ブルートフォース攻撃を行うことができ、1秒あたり数十億のパスワードを推測しようとします。 そのため、リソースへのアクセスに使用されるパスワードは強力で、さまざまな文字が使用されることが重要です。 これらのパスワードは、覚えにくいパスワードの種類です。 幸い、Azure のパスワードは、実際には人間が知っている必要はありません。

多くのセキュリティ[専門家](https://www.troyhunt.com/password-managers-dont-have-to-be-perfect-they-just-have-to-be-better-than-not-having-one/)は、パスワードマネージャーを使用して自分のパスワードを保持することをお勧めします。 パスワードは1か所に一元化されますが、非常に複雑なパスワードを使用して、アカウントごとに一意にすることができます。 Azure 内には、シークレットの中央ストアと同じシステムが存在します。

## <a name="azure-key-vault"></a>Azure Key Vault

Azure Key Vault には、データベース、API キー、証明書などのパスワードを格納するための一元的な場所が用意されています。 資格情報コンテナーにシークレットを入力すると、再度表示されることはなく、抽出して表示するコマンドが意図的に複雑になります。 安全なの情報は、ソフトウェアの暗号化、または FIPS 140-2 レベル2の検証済みハードウェアセキュリティモジュールを使用して保護されています。

キーコンテナーへのアクセスは、Rbac Acs によって提供されます。つまり、コンテナー内の情報にアクセスできるユーザーだけではありません。 Azure Key Vault に格納されているデータベース接続文字列にアクセスする web アプリケーションがあるとします。 アクセスするには、サービスプリンシパルを使用してアプリケーションを実行する必要があります。 この想定された役割では、安全なシークレットを読み取ることができます。 アプリケーションの資格情報コンテナーへのアクセスを制限できるさまざまなセキュリティ設定があります。これにより、機密情報を更新することはできず、読み取りのみが可能になります。

Key vault へのアクセスを監視して、予期されるアプリケーションだけが資格情報コンテナーにアクセスするようにすることができます。 ログは、予期しない状態が発生したときにアラートを設定する機能のロックを解除して、Azure Monitor に戻すことができます。

## <a name="kubernetes"></a>Kubernetes

Kubernetes 内には、少数の機密情報を保持するための類似したサービスがあります。 Kubernetes シークレットは、一般的な実行可能ファイルを使用して設定でき `kubectl` ます。

シークレットの作成は、格納される値の base64 バージョンを検索するのと同じように簡単です。

```console
echo -n 'admin' | base64
YWRtaW4=
echo -n '1f2d1e2e67df' | base64
MWYyZDFlMmU2N2Rm
```

次の例のように、これをという名前のシークレットファイルに追加し `secret.yml` ます。

```yml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
```

最後に、次のコマンドを実行して、このファイルを Kubernetes に読み込むことができます。

```console
kubectl apply -f ./secret.yaml
```

これらのシークレットは、ボリュームにマウントしたり、環境変数を介してコンテナープロセスに公開したりすることができます。 アプリケーションを構築するための[12 要素アプリ](https://12factor.net/)のアプローチでは、最も低い共通の分母を使用して、アプリケーションに設定を送信することをお勧めします。 環境変数は、オペレーティングシステムやアプリケーションに関係なくサポートされるため、最も一般的な分母です。

組み込みの Kubernetes シークレットを使用する代わりに、Kubernetes 内から Azure Key Vault のシークレットにアクセスすることもできます。 これを行う最も簡単な方法は、シークレットを読み込むコンテナーに RBAC ロールを割り当てることです。 その後、アプリケーションは、Azure Key Vault Api を使用してシークレットにアクセスできます。 ただし、この方法ではコードを変更する必要があり、環境変数を使用するパターンには従っていません。 代わりに、 [Azure Key Vault インジェクター](https://mrdevops.io/introducing-azure-key-vault-to-kubernetes-931f82364354)を使用して、コンテナーに値を挿入することができます。 この方法は、クラスター上のユーザーがアクセスできるため、Kubernetes シークレットを直接使用するよりも安全です。

## <a name="encryption-in-transit-and-at-rest"></a>転送中および保存中の暗号化

データの安全性を維持することは、ディスク上にあるか、さまざまなサービス間の通過であるかにかかわらず重要です。 データのリークを防ぐための最も効果的な方法は、他のユーザーが簡単に読み取ることができない形式にデータを暗号化することです。 Azure では、幅広い暗号化オプションがサポートされています。

### <a name="in-transit"></a>転送中のデータ

Azure でネットワーク上のトラフィックを暗号化するには、いくつかの方法があります。 Azure サービスへのアクセスは、通常、TLS (Transport Layer Security) を使用する接続を介して行われます。 たとえば、Azure Api へのすべての接続に TLS 接続が必要です。 同様に、Azure storage 内のエンドポイントへの接続は、TLS で暗号化された接続でのみ機能するように制限できます。

TLS は複雑なプロトコルであり、接続が TLS を使用していることを確認するだけでは十分ではありません。 たとえば、TLS 1.0 は一様セキュリティで保護されておらず、TLS 1.1 の方がはるかに適していません。 TLS のバージョン内でも、接続を簡単に復号化できるようにするさまざまな設定があります。 最良の措置は、サーバー接続が最新のプロトコルを使用しているかどうかを確認し、適切に構成されたプロトコルを確認することです。

このチェックは、SSL labs の SSL サーバーテストなどの外部サービスによって実行できます。 一般的な Azure エンドポイント (この場合は service bus エンドポイント) に対してテストを実行すると、のほぼ完全なスコアが生成されます。

Azure SQL データベースなどのサービスでも、データを非表示に保つために TLS 暗号化が使用されます。 TLS を使用した転送中のデータの暗号化に関する興味深い点は、Microsoft が TLS を実行するコンピューター間の接続をリッスンすることができないことです。 これにより、データがマイクロソフトの適切なリスクにさらされているか、標準攻撃者よりも多くのリソースを持つ状態アクターであっても、安心感を得ることができます。

![図 9-5 Service Bus エンドポイントののスコアを示す SSL labs レポート](./media/ssl-report.png)

**図 9-5** Service Bus エンドポイントののスコアを示す SSL ラボレポート。

このレベルの暗号化は、すべての時間にとって十分ではありませんが、Azure TLS 接続が非常に安全であるという自信を持つ必要があります。 Azure は、暗号化の強化に伴ってセキュリティ標準を進化させ続けています。 セキュリティ標準を監視し、改善に応じて Azure を更新していることを理解しておくと便利です。

### <a name="at-rest"></a>保存中

どのアプリケーションでも、データがディスク上に置かれている場所がいくつかあります。 アプリケーションコード自体は、いくつかのストレージメカニズムから読み込まれます。 ほとんどのアプリケーションでは、SQL Server、Cosmos DB、または驚くほどのコスト効率のよい Table Storage など、何らかの種類のデータベースも使用します。 これらのデータベースはすべて、高い暗号化ストレージを使用して、適切なアクセス許可を持つアプリケーション以外のユーザーがデータを読み取ることができるようにします。 システム演算子でも、暗号化されたデータを読み取ることはできません。 そのため、お客様は機密情報を秘密に保つことができます。

### <a name="storage"></a>ストレージ

Azure の中核的土台の多くは、Azure Storage エンジンです。 仮想マシンのディスクは Azure Storage 上にマウントされます。 Azure Kubernetes サービスは、それ自体が Azure Storage でホストされる仮想マシン上で実行されます。 Azure Functions アプリや Azure Container Instances などのサーバーレステクノロジでも、Azure Storage に含まれるディスクが不足しています。

Azure Storage が適切に暗号化されている場合は、他のほとんどすべてのものを暗号化するための基盤が提供されます。 Azure Storage は、 [FIPS 140-2](https://en.wikipedia.org/wiki/FIPS_140)準拠の[256 ビット AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)で[暗号化さ](https://docs.microsoft.com/azure/storage/common/storage-service-encryption)れます。 これは、過去20年間にわたるさまざまな教育機関の審査の対象となっている、よく考えられる暗号化テクノロジです。 現時点では、キーに関する知識のないユーザーが AES によって暗号化されたデータを読み取ることを可能にする既知の実用的な攻撃はありません。

既定では、Azure Storage の暗号化に使用されるキーは、Microsoft によって管理されます。 これらのキーへの悪意のあるアクセスを防ぐために、広範な保護が実施されています。 ただし、特定の暗号化要件を持つユーザーは、Azure Key Vault で管理されている[独自のストレージキーを提供](https://docs.microsoft.com/azure/storage/common/storage-encryption-keys-powershell)することもできます。 これらのキーはいつでも取り消すことができます。これにより、ストレージアカウントの内容がアクセス不可能な状態で実質的に表示されます。

仮想マシンは暗号化された記憶域を使用しますが、Windows の BitLocker や Linux 上の DM-Crypt などのテクノロジを使用して、別の暗号化レイヤーを提供することもできます。 これらのテクノロジは、ディスクイメージが記憶域からリークされた場合でも、それを読み取ることができない状態を維持することを意味します。

### <a name="azure-sql"></a>Azure SQL

Azure SQL でホストされているデータベースは、データを暗号化したままにするために[Transparent Data Encryption (TDE)](/sql/relational-databases/security/encryption/transparent-data-encryption)と呼ばれるテクノロジを使用します。 新しく作成されたすべての SQL データベースでは、既定で有効になっていますが、レガシデータベースでは手動で有効にする必要があります。 TDE は、データベースだけでなく、バックアップとトランザクションログのリアルタイム暗号化と復号化を実行します。

暗号化パラメーターはデータベースに格納され、 `master` 起動時に残りの操作のためにメモリに読み込まれます。 つまり、データベースは `master` 暗号化されずに保持される必要があります。 実際のキーは、Microsoft によって管理されています。 ただし、厳しいセキュリティ要件を持つユーザーは、Azure Storage の場合とほぼ同じ方法で Key Vault で独自のキーを提供できます。 Key Vault は、キーのローテーションや失効などのサービスを提供します。

TDS の "透過的な" 部分は、暗号化されたデータベースを使用するためにクライアントの変更が必要ないという事実に由来します。 この方法では優れたセキュリティを実現できますが、データベースのパスワードをリークすると、ユーザーがデータを復号化できるようになります。 データベース内の個々の列またはテーブルを暗号化する別の方法もあります。 [Always Encrypted](https://docs.microsoft.com/azure/sql-database/sql-database-always-encrypted-azure-key-vault)は、暗号化されたデータがデータベース内にプレーンテキストで表示されることを保証します。

この暗号化レベルを設定するには、SQL Server Management Studio のウィザードを使用して、暗号化の種類と、関連付けられているキーを格納する Key Vault の場所を選択する必要があります。

![図 9-6 Always Encrypted を使用して暗号化するテーブル内の列を選択する](./media/always-encrypted.png)

**図 9-6**. Always Encrypted を使用して暗号化するテーブルの列を選択します。

これらの暗号化された列から情報を読み取るクライアントアプリケーションでは、暗号化されたデータを読み取るために特別な許容値を設定する必要があります。 接続文字列はで更新する必要があり、 `Column Encryption Setting=Enabled` Key Vault からクライアント資格情報を取得する必要があります。 その後、SQL Server クライアントは、列の暗号化キーを使用して準備を行う必要があります。 この処理が完了すると、残りのアクションは標準のインターフェイスを SQL クライアントに使用します。 つまり、SQL クライアント上に構築されている Dapper や Entity Framework などのツールは、変更を加えずに引き続き動作します。 Always Encrypted は、すべての言語のすべての SQL Server ドライバーでまだ使用できるわけではありません。

TDE と Always Encrypted の組み合わせによって、クライアント固有のキーと共に使用することができ、最も厳しい暗号化要件がサポートされるようになります。

### <a name="cosmos-db"></a>Cosmos DB

Cosmos DB は、Azure で Microsoft が提供する最新のデータベースです。 セキュリティと暗号化を考慮して、一から構築されています。 AES-256 ビット暗号化は、すべての Cosmos DB データベースの標準であり、無効にすることはできません。 通信の TLS 1.2 要件と組み合わせると、ストレージソリューション全体が暗号化されます。

![図 9-7 Cosmos DB 内のデータ暗号化のフロー](./media/cosmos-encryption.png)

**図 9-7**. Cosmos DB 内のデータ暗号化のフロー。

Cosmos DB は顧客の暗号化キーの提供には対応していませんが、チームによって、PCI DSS に準拠していることを確認するための重要な作業が行われています。 また Cosmos DB は、Azure SQL の Always Encrypted と同様に、どのような種類の列暗号化もサポートしていません。

## <a name="keeping-secure"></a>セキュリティを維持する

Azure には、高度なセキュリティで保護された製品をリリースするために必要なすべてのツールがあります。 ただし、チェーンは最も弱いリンクとしてのみ強力です。 Azure 上にデプロイされたアプリケーションが、適切なセキュリティマインドと優れたセキュリティ監査を使用して開発されていない場合は、チェーン内の脆弱なリンクになります。 Azure にインストールされたソフトウェアが Azure 自体と同じようにセキュリティで保護されていることを確認するために使用できる、多くの優れた静的分析ツール、暗号化ライブラリ、およびセキュリティプラクティスがあります。 例としては、[静的分析ツール](https://www.whitesourcesoftware.com/)、[暗号化ライブラリ](https://www.libressl.org/)、[セキュリティプラクティス](https://azure.microsoft.com/resources/videos/red-vs-blue-internal-security-penetration-testing-of-microsoft-azure/)などがあります。

>[!div class="step-by-step"]
>[前へ](security.md)
>[次へ](devops.md)
