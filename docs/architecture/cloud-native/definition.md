---
title: クラウド ネイティブの定義
description: クラウドネイティブシステムの基盤を提供する基本的な柱について説明します。
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: e8b07fe7758d90f6ba97b81d0efa9d2fb5058d49
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614177"
---
# <a name="defining-cloud-native"></a>クラウドネイティブの定義

作業内容を停止し、10人の同僚のテキストを入力します。 「クラウドネイティブ」という用語を定義するように依頼します。 10件の異なる回答が得られる可能性が高くなります。

クラウドネイティブは、重要なビジネスシステムの構築について考える方法を変更することです。

クラウドネイティブシステムは、迅速な変更、大規模、および回復力を採用するように設計されています。

クラウドネイティブコンピューティングファンデーションは、[公式の定義](https://github.com/cncf/foundation/blob/master/charter.md)を提供します。

> *クラウドネイティブテクノロジを利用すると、パブリック、プライベート、ハイブリッドクラウドなどの最新の動的環境でスケーラブルなアプリケーションを構築し、実行することができます。コンテナー、サービスメッシュ、マイクロサービス、不変のインフラストラクチャ、および宣言型 Api は、この方法を知性します。*

> *これらの手法は、回復性、管理性、監視可能な疎結合システムを実現します。堅牢な自動化と組み合わせることにより、エンジニアは働いを最小限に抑えながら、大きな影響を与える変化を頻繁に行うことができます。*

アプリケーションがますます複雑になり、ユーザーはさらに多くの要求を行うようになりました。 ユーザーは、迅速な応答性と革新的な機能を期待し、ダウンタイムをゼロにする必要があります。 パフォーマンスの問題、繰り返し発生するエラー、および高速に移行できないことが許容されなくなりました。 これらのユーザーは、競合他社に簡単に移行できます。

クラウドネイティブでは、*速度*と*機敏性*が大幅に向上しています。 ビジネスシステムは、ビジネス機能を可能にして戦略的変革を実現し、ビジネスの速度と成長を加速させることに発展しています。 市場でアイデアをすぐに得ることが不可欠です。

ここでは、これらの手法を実装した企業をいくつか紹介します。 実現したスピード、機敏性、およびスケーラビリティについて考えてみましょう。

| [会社] | エクスペリエンス |
| :-------- | :-------- |
| [Netflix](https://www.infoq.com/news/2013/06/netflix/) | 実稼働環境で600以上のサービスをご用意しています。 1日に100回デプロイします。 |
| [Uber](https://eng.uber.com/micro-deploy/) | 運用環境に1,000 を超えるサービスがあります。 週ごとに数千回デプロイされます。 |
| [WeChat](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | 運用環境には300を超えるサービスがあります。 1日に1000回デプロイします。 |

ご覧のように、Netflix、Uber、w は、数百の独立したマイクロサービスで構成されるシステムを公開しています。 このアーキテクチャスタイルを使用すると、市場の状況に迅速に対応できます。 ライブで複雑なアプリケーションの小さな領域を瞬時に更新し、必要に応じてそれらの領域を個別にスケールできます。

クラウドネイティブの速度と機敏性は、さまざまな要因によって発生します。 最も重要なのはクラウドインフラストラクチャです。 図1-3 に示す5つの追加の基本柱も、クラウドネイティブシステムの基盤を提供します。

![クラウドネイティブの基本柱](./media/cloud-native-foundational-pillars.png)

**図 1-3**. クラウドネイティブの基本柱

各柱の有意性をさらに理解するために、少し時間を取ってみましょう。

## <a name="the-cloud"></a>クラウド...

クラウドネイティブシステムは、クラウドサービスモデルを最大限に活用します。

動的な仮想化されたクラウド環境で実現するように設計されたこれらのシステムでは、[サービスとしてのプラットフォーム (PaaS)](https://azure.microsoft.com/overview/what-is-paas/)コンピューティングインフラストラクチャと管理対象サービスが広く使用されています。 基になるインフラストラクチャは、数分で*破棄*可能なプロビジョニング済みとして扱われ、オンデマンドでサイズ変更、拡大縮小、移動、または破棄されます。

[ペットと家畜](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)の間で広く受け入れられている DevOps の概念を検討してください。 従来のデータセンターでは、サーバーは*ペット*として扱われます。物理マシンには、意味のある名前が与えられ、には紛れがあります。 同じコンピューター (スケールアップ) にリソースを追加することによって、スケーリングします。 サーバーが病気になった場合、そのサーバーは正常性に戻ります。 サーバーが使用できなくなった場合、すべてのユーザーに通知されます。

*家畜*サービスモデルは異なります。 各インスタンスは、仮想マシンまたはコンテナーとしてプロビジョニングします。 これらは同一であり、Service 01、Service 02 などのシステム識別子が割り当てられています。 さらに多くのもの (スケールアウト) を作成することによってスケーリングします。 1つが使用できなくなった場合は、だれも通知しません。

家畜モデルは、*不変のインフラストラクチャ*を採用しています。 サーバーが修復または変更されていません。 失敗した場合、または更新が必要な場合は、破棄され、新しいものがプロビジョニングされます (すべてのオートメーションを通じて実行されます)。

クラウドネイティブシステムは、家畜サービスモデルを採用しています。 インフラストラクチャが実行されているコンピューターに関係なく、インフラストラクチャのスケールインまたはスケールアウトを実行し続けます。

Azure クラウドプラットフォームでは、自動スケーリング、自己復旧、および監視機能を備えた、この種類の高度なエラスティックインフラストラクチャがサポートされています。

## <a name="modern-design"></a>モダン デザイン

クラウドネイティブアプリを設計するにはどうすればよいですか。 アーキテクチャはどのようなものでしょうか。 どのような原則、パターン、およびベストプラクティスを遵守しますか。 インフラストラクチャと運用上の懸念事項はどのようなものですか。

### <a name="the-twelve-factor-application"></a>12要素アプリケーション

クラウドベースのアプリケーションを構築するための広く受け入れられた方法は、 [12 要素アプリケーション](https://12factor.net/)です。 ここでは、最新のクラウド環境向けに最適化されたアプリケーションを構築するために開発者が従う一連の原則と方法について説明します。 環境間の移植性と宣言型の自動化には、特に注意が払われています。

Web ベースのアプリケーションにも当てはまりますが、多くの専門家は、クラウドネイティブアプリを構築するための堅固な基盤として12要素を検討しています。 これらの原則に基づいて構築されたシステムでは、迅速にデプロイしてスケーリングし、市場の変化に迅速に対応する機能を追加できます。

次の表は、12要素の手法を示しています。

|    |  要素 | 説明  |
| :-------- | :-------- | :-------- |
| 1 | コードベース | 各マイクロサービスの1つのコードベースが、独自のリポジトリに格納されています。 バージョン管理で追跡され、複数の環境 (QA、ステージング、運用環境) にデプロイできます。 |
| 2 | 依存関係 | 各マイクロサービスは、独自の依存関係を分離およびパッケージ化し、システム全体に影響を与えることなく変更を行います。 |
| 3 | 構成  | 構成情報は、コードの外部にある構成管理ツールを使用して、マイクロサービスから外部化に移動されます。 同じデプロイは、適切な構成が適用された環境間で伝達できます。  |
| 4 | サービスのバックアップ | 補助リソース (データストア、キャッシュ、メッセージブローカー) は、アドレス指定可能な URL を介して公開する必要があります。 これにより、アプリケーションからリソースが分離され、それを交換可能にすることができます。  |
| 5 | ビルド、リリース、実行 | 各リリースでは、ビルド、リリース、および実行の各段階で厳密な分離を適用する必要があります。 各には一意の ID をタグ付けし、ロールバックの機能をサポートしている必要があります。 最新の CI/CD システムは、この原則を満たすのに役立ちます。 |
| 6 | 処理 | 各マイクロサービスは、実行中の他のサービスから分離された独自のプロセスで実行する必要があります。 外部化は、分散キャッシュやデータストアなどのバッキングサービスに必要な状態を提供します。 |
| 7 | [ポートのバインド] | 各マイクロサービスは、独自のポートで公開されているインターフェイスと機能と共に自己完結している必要があります。 これにより、他のマイクロサービスから分離されます。 |
| 8 | コンカレンシー | サービスは、最も強力なコンピューター上で1つの大きなインスタンスをスケールアップするのではなく、多数の小さな同一のプロセス (コピー) を使用してスケールアウトします。 |
| 9 | Disposability | サービスインスタンスは、システムを適切な状態に保つために、スケーラビリティの機会と正常なシャットダウンを向上させるために、優先 fast スタートアップにする必要があります。 Docker コンテナーと orchestrator は、本質的にこの要件を満たしています。 |
| 10 | 開発/運用のパリティ | アプリケーションライフサイクル全体の環境を可能な限り維持し、コストのかかるショートカットを回避します。 ここでは、同じ実行環境を昇格することで、コンテナーの導入が非常に困難になる場合があります。 |
| 11 | ログ記録 | マイクロサービスによって生成されたログをイベントストリームとして扱います。 イベントアグリゲーターを使用して処理し、データをデータマイニング/ログ管理ツールに伝達します。これには Azure Monitor や、最終的には長期間のアーカイブが含まれます。 |
| 12 | 管理プロセス | 管理タスクと管理タスクを1回限りのプロセスとして実行します。 タスクには、レポートのデータクリーンアップとプル分析を含めることができます。 これらのタスクを実行するツールは、運用環境から、アプリケーションとは別に呼び出す必要があります。 |

この書籍では、 [12 要素アプリ以外](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)に、2011で記述された元の12個の要素のそれぞれについて説明しています。 さらに、今日の最新のクラウドアプリケーション設計を反映する3つの追加要素についても説明します。

|    |  新しい係数 | 説明  |
| :-------- | :-------- | :-------- |
| 13 | API ファースト | すべてのサービスを作成します。 コードがフロントエンドクライアント、ゲートウェイ、または別のサービスによって使用されるとします。 |
| 14 | テレメトリ | ワークステーションには、アプリケーションとその動作の詳細が表示されます。 クラウドでは、そうではありません。 監視、ドメイン固有、およびシステムデータのコレクションが設計に含まれていることを確認します。 |
| 15 | 認証/承認  | Start から id を実装します。 パブリッククラウドで利用できる[RBAC (ロールベースのアクセス制御)](https://docs.microsoft.com/azure/role-based-access-control/overview)機能を検討してください。  |

この章では、12以上の要素の多くを紹介します。

### <a name="critical-design-considerations"></a>重要な設計上の考慮事項

12要素手法から提供されるガイダンス以外にも、分散システムを構築する際には、いくつかの重要な設計上の決定を行う必要があります。

*通信*

フロントエンドクライアントアプリケーションは、どのようにして、バックエンドのコアサービスと通信しますか。 直接通信を許可しますか? または、柔軟性、制御、およびセキュリティを提供するゲートウェイファサードを使用してバックエンドサービスを抽象化する場合もあります。

バックエンドコアサービスが相互に通信する方法 結合につながる直接の HTTP 呼び出しを許可し、パフォーマンスと機敏性に影響を与えますか。 また、キューとトピックテクノロジを使用してメッセージングを分離することも考えられます。

通信の詳細については、「*クラウドネイティブの通信パターン*4」を参照してください。

*回復性*

マイクロサービスアーキテクチャは、インプロセスからアウトプロセスのネットワーク通信にシステムを移行します。 分散アーキテクチャでは、サービス B がサービス A からのネットワーク呼び出しに応答しない場合、どのような処理が行われますか。 また、サービス C が一時的に使用できなくなり、その他のサービスを呼び出すサービスがブロックされた場合はどうなるでしょうか。

回復性については、第6章「*クラウドネイティブの回復性*」を参照してください。

*分散データ*

仕様により、各マイクロサービスは独自のデータをカプセル化し、パブリックインターフェイスを介して操作を公開します。 その場合、データを照会したり、複数のサービスにわたってトランザクションを実装したりするにはどうすればよいでしょうか。

分散データの詳細については、「*クラウドネイティブデータパターン*5」を参照してください。

*ID*

サービスがアクセスしているユーザーとそのアクセス許可はどのように識別されますか。

Id の詳細については、「8. *id*」を参照してください。

## <a name="microservices"></a>マイクロサービス

クラウドネイティブシステムは、最新のアプリケーションを構築するための一般的なアーキテクチャスタイルであるマイクロサービスを採用しています。

共有ファブリックを介してやり取りする小規模で独立したサービスの分散セットとして構築されたマイクロサービスは、次の特性を共有します。

- 各は、より大きなドメインコンテキスト内で特定のビジネス機能を実装します。

- 各は自律的に開発され、個別にデプロイできます。

- それぞれのデータストレージテクノロジ (SQL、NoSQL) およびプログラミングプラットフォームは自己完結型でカプセル化されています。

- それぞれが独自のプロセスで実行され、HTTP/HTTPS、Websocket、 [Amqp](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)などの標準的な通信プロトコルを使用して他のユーザーと通信します。

- これらは、アプリケーションを形成するためにまとめられています。

図1-4 は、モノリシックアプリケーションアプローチとマイクロサービスアプローチの違いを比較したものです。 モノリスは、1つのプロセスで実行される多層アーキテクチャで構成されていることに注意してください。 通常、リレーショナルデータベースを消費します。 ただし、マイクロサービスアプローチは、ロジックとデータを含む独立したサービスに分離機能を備えています。 各マイクロサービスは、独自のデータストアをホストします。

![モノリシックデプロイとマイクロサービス](./media/monolithic-vs-microservices.png)

**図 1-4.** モノリシックデプロイとマイクロサービス

「」で前述したように、マイクロサービスが[12 要素アプリケーション](https://12factor.net/)から "1 つのコードベース (1 つのアプリケーション)" プリンシパルを昇格する方法に注意してください。

> *因子 \# 1 では、それぞれのリポジトリに格納されているマイクロサービスごとに1つのコードベースを指定します。バージョン管理を使用して追跡され、複数の環境に配置できます。 "*

### <a name="why-microservices"></a>マイクロサービスについて

マイクロサービスは機敏性を提供します。

前の章では、マイクロサービスを使用したモノリスとして構築された電子商取引アプリケーションを比較しています。 この例では、いくつかの明確な利点があります。

- 各マイクロサービスには自律したライフサイクルがあり、個別に進化して頻繁に展開することができます。 四半期ごとのリリースが新しい機能をデプロイしたり更新したりするまで待つ必要はありません。 システム全体を中断するリスクを軽減することで、複雑なアプリケーションの小さな領域を更新することができます。

- 各マイクロサービスは個別にスケーリングできます。 アプリケーション全体を1つのユニットとしてスケールアウトするのではなく、より多くの処理能力やネットワーク帯域幅を必要とするサービスのみをスケールアウトします。 このように細分化されたスケーリングのアプローチによって、システムをより細かく制御し、システム全体ではなく、システムの一部をスケールするときに全体的なコストを削減することができます。

マイクロサービスを理解するための優れたリファレンスガイドは、 [.Net マイクロサービス: コンテナー化された .Net アプリケーションのアーキテクチャ](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)です。 この書籍は、マイクロサービスの設計とアーキテクチャに深くダイブしています。 これは、Microsoft から無料でダウンロードできる[フルスタックマイクロサービス参照アーキテクチャ](https://github.com/dotnet-architecture/eShopOnContainers)のコンパニオンです。

### <a name="developing-microservices"></a>マイクロサービスの開発

マイクロサービスは、最新の開発プラットフォームを使用して作成できます。

Microsoft .NET コアプラットフォームが最適な選択肢です。 無料のオープンソースとして、マイクロサービスの開発を簡略化する組み込みの機能が多数用意されています。 .NET Core はクロスプラットフォームです。 アプリケーションは、Windows、macOS、およびほとんどの Linux でビルドして実行できます。

.NET Core は高いパフォーマンスを発揮し、node.js とその他の競合するプラットフォームとの比較においても十分に評価されています。 興味深いこと[に、多くの web](https://www.techempower.com/)アプリケーションプラットフォームとフレームワークで、豊富な[パフォーマンスベンチマーク](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)が実行されています。 .NET Core は、node.js などの競合しているプラットフォーム上の上位10件でスコア付けされています。

.NET Core は、GitHub の Microsoft および .NET コミュニティによって管理されています。

## <a name="containers"></a>Containers

今日では、*クラウドのネイティブ*に関するメッセージ交換で言及されている用語*コンテナー*を聞いています。 この本の[クラウドネイティブパターン](https://www.manning.com/books/cloud-native-patterns)では、"コンテナーはクラウドネイティブソフトウェアの優れた Cornelia" です。 クラウドネイティブコンピューティングファンデーションは、クラウドネイティブの[トレイル地図](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)の最初の手順として、マイクロサービスコンテナー化を配置します。企業がクラウドネイティブの体験を開始するガイダンスです。

マイクロサービスのコンテナー化はシンプルで簡単です。 コード、その依存関係、およびランタイムは、[コンテナーイメージ](https://docs.docker.com/glossary/?term=image)と呼ばれるバイナリにパッケージ化されます。 イメージは、イメージのリポジトリまたはライブラリとして機能する[コンテナーレジストリ](https://caylent.com/container-registries/)に格納されます。 レジストリは、開発用コンピューター、データセンター、またはパブリッククラウドに配置できます。 Docker 自体は、 [Docker Hub](https://hub.docker.com/)を使用してパブリックレジストリを管理します。 Azure クラウドでは、コンテナー[レジストリ](https://azure.microsoft.com/services/container-registry/)が機能し、コンテナーイメージを実行するクラウドアプリケーションの近くに格納されます。

必要に応じて、イメージを実行中のコンテナーインスタンスに変換します。 インスタンスは、[コンテナーランタイム](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)エンジンがインストールされている任意のコンピューター上で実行されます。 コンテナー化されたサービスのインスタンスは、必要に応じていくつでも作成できます。

図1-5 は、それぞれが1つのホストで実行される3つの異なるマイクロサービスをそれぞれのコンテナーに示しています。

![コンテナー ホストで実行されている複数のコンテナー](./media/hosting-mulitple-containers.png)

**図 1-5**. コンテナー ホストで実行されている複数のコンテナー

各コンテナーが独自の依存関係とランタイムのセットを保持していることに注意してください。異なる可能性があります。 ここでは、同じホストで実行されている異なるバージョンの製品マイクロサービスを示します。 各コンテナーは、基礎となるホストオペレーティングシステム、メモリ、およびプロセッサのスライスを共有しますが、互いに分離されています。

コンテナーモデルが、 [12 要素アプリケーション](https://12factor.net/)からの "依存関係" の原則をどの程度採用しているかに注目してください。

> *係数 \# 2 は、"各マイクロサービスが独自の依存関係を分離およびパッケージ化し、システム全体に影響を与えることなく変更を行うことを指定します。"*

コンテナーは、Linux と Windows の両方のワークロードをサポートします。 Azure クラウドは、両方をオープンにしています。 興味深いことに、Azure で最も一般的なオペレーティングシステムになっている Windows Server ではなく Linux です。

複数のコンテナーベンダーが存在していても、Docker はライオンの市場シェアを獲得しています。 会社はソフトウェアコンテナーの移動を推進しています。 クラウドネイティブアプリケーションのパッケージ化、デプロイ、実行のための事実上の標準になっています。

### <a name="why-containers"></a>コンテナーを選ぶ理由

コンテナーは、環境間での移植性と整合性を保証します。 すべてを1つのパッケージにカプセル化することで、マイクロサービスとその依存関係を基になるインフラストラクチャから*分離*します。

Docker ランタイムエンジンを持つ任意の環境に同じコンテナーを配置できます。 コンテナー化されたワークロードでは、フレームワーク、ソフトウェアライブラリ、およびランタイムエンジンを使用して各環境を事前に構成する費用も不要になります。

基盤となるオペレーティングシステムとホストリソースを共有することで、コンテナーのフットプリントは、完全な仮想マシンよりもかなり小さくなります。 サイズを小さくすると、特定のホストが一度に実行できる*密度*(マイクロサービスの数) が増加します。

### <a name="container-orchestration"></a>コンテナーのオーケストレーション

Docker、イメージの作成、コンテナーの実行などのツールでは、それらを管理するためのツールも必要です。 コンテナー管理は、コンテナー orchestrator と呼ばれる特別なソフトウェアプログラムを使用して行われます。 大規模に運用する場合は、コンテナーオーケストレーションが不可欠です。

図1-6 は、コンテナーオーケストレーター提供する管理タスクを示しています。

![コンテナーオーケストレーター行うこと](./media/what-container-orchestrators-do.png)

**図 1-6**. コンテナーオーケストレーター行うこと

次の表では、一般的なオーケストレーションタスクについて説明します。

|  タスク | 説明  |
| :-------- | :-------- |
| スケジュール設定 | コンテナーインスタンスを自動的にプロビジョニングします。|
| アフィニティ/アンチアフィニティ | 隣接しているコンテナーまたは遠く離れたコンテナーを相互にプロビジョニングし、可用性とパフォーマンスを高めます。 |
| 正常性の監視 | エラーを自動的に検出して修正します。|
| [フェールオーバー] | 失敗したインスタンスを正常なコンピューターに自動的に再プロビジョニングします。|
| Scaling | 必要に応じて、コンテナーインスタンスを自動的に追加または削除します。|
| ネットワーク | コンテナー通信のネットワークオーバーレイを管理します。|
| サービス探索 | コンテナーが相互に配置されるようにします。|
| ローリングアップグレード | ダウンタイムをゼロに配置して増分アップグレードを調整します。 問題のある変更を自動的にロールバックします。|

この章で既に説明したように、オーケストレーター [12 要素アプリケーション](https://12factor.net/)から disposability と同時実行の原則を採用していることに注意してください。

> *係数 \# 9 は、"サービスインスタンスを破棄可能にして、スケーラビリティの機会を増やし、グレースフルシャットダウンを優先してシステムを適切な状態に保つことを指定します。Docker コンテナーと orchestrator は、本質的にこの要件を満たしています。 "*

> *要素 \# 8 では、使用可能な最も強力なコンピューター上で1つの大きなインスタンスをスケールアップするのではなく、多数の小さい同一のプロセス (コピー) に対してサービスをスケールアウトすることを指定します。*

複数のコンテナーオーケストレーター存在していても、 [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)はクラウドネイティブ環境では事実上標準になりました。 コンテナー化されたワークロードを管理するための、移植可能で拡張可能なオープンソースのプラットフォームです。

Kubernetes の独自のインスタンスをホストすることもできますが、リソースのプロビジョニングと管理は複雑になる可能性があります。 Azure クラウドの機能 Kubernetes は、管理されたサービスである[Azure Kubernetes service (AKS)](https://azure.microsoft.com/services/kubernetes-service/)として機能します。 管理されたサービスを使用すると、その機能をインストールして保守しなくても、機能を完全に活用できます。

Azure Kubernetes Services の詳細については、「*クラウドネイティブアプリケーションのスケーリング*」を参照してください。

## <a name="backing-services"></a>サービスのバックアップ

クラウドネイティブシステムは、データストア、メッセージブローカー、監視、id サービスなど、さまざまな補助リソースに依存しています。 これらのサービスは、[バッキングサービス](https://12factor.net/backing-services)と呼ばれています。

 図1-7 は、クラウドネイティブシステムが使用する多くの一般的なバッキングサービスを示しています。

![一般的なバッキングサービス](./media/common-backing-services.png)

**図 1-7**. 一般的なバッキングサービス

バッキングサービスは、前の章で説明した[12 要素アプリケーション](https://12factor.net/)からの "状態" 原則を昇格させます。

>*係数 \# 6*は、"各マイクロサービスを、実行中の他のサービスから分離された独自のプロセスで実行する必要があることを指定します。 分散キャッシュやデータストアなどのバッキングサービスに必要な状態を外部化。 "

独自のバッキングサービスをホストすることもできますが、その場合は、これらのリソースのライセンス、プロビジョニング、および管理を行う必要があります。

クラウドプロバイダーは、さまざまな*マネージドバッキングサービスを提供しています。* サービスを所有するのではなく、単に使用します。 プロバイダーは、大規模なリソースを操作し、パフォーマンス、セキュリティ、およびメンテナンスの責任を担います。 サービスには、監視、冗長性、可用性が組み込まれています。 プロバイダーは、管理されたサービスを完全にサポートしています。チケットを開いて問題を解決します。

クラウドネイティブシステムは、クラウドベンダーのマネージドバッキングサービスを優先します。 時間と労力が節約されています。 独自にホストし、問題が発生した場合の運用上のリスクは、コストがかかることがあります。

ベストプラクティスとして、バッキングサービスを接続されたリソースとして扱い、外部構成に格納されて*いる*情報 (URL と資格情報) を使用してマイクロサービスに動的にバインドすることをお勧めします。 このガイダンスは、前の章で説明した[12 要素のアプリケーション](https://12factor.net/)でスペルが示されています。

>*係数 \# 4*は、アドレス指定可能な URL を使用してバッキングサービスを公開する必要があることを指定します。 これにより、アプリケーションからリソースが分離され、そのリソースを交換可能にすることができます。 "

>*係数 \# 3*は、"構成情報がマイクロサービスの外に移動され、構成管理ツールを使用してコード外に外部化する" ことを指定します。

このパターンでは、コードを変更せずに、バッキングサービスをアタッチおよびデタッチできます。 マイクロサービスを QA からステージング環境に昇格させることができます。 マイクロサービス構成を更新して、ステージング環境のバッキングサービスをポイントし、環境変数を使用して設定をコンテナーに挿入します。

クラウドベンダーは、独自のバッキングサービスと通信するための Api を提供しています。 これらのライブラリは、プラミングと複雑さをカプセル化します。 これらの Api と直接通信することにより、コードをバッキングサービスに密に結合できます。 ベンダ API の実装の詳細を分離することをお勧めします。 Intermediation 層 (中間 API) を導入して、サービスコードに汎用的な操作を公開します。 この疎結合により、1つのバッキングサービスを別のサービスにスワップアウトしたり、メインのサービスコードを変更しなくても、別のパブリッククラウドにコードを移動したりできます。

バッキングサービスの詳細については、「5章、*クラウドネイティブのデータパターン*」、および「*クラウドネイティブの通信パターン*」を参照してください。

## <a name="automation"></a>オートメーション

既に説明したように、クラウドネイティブシステムは、高速で機敏性を実現するために、マイクロサービス、コンテナー、および最新のシステム設計を採用しています。 しかし、これはストーリーの一部にすぎません。 これらのシステムを実行するクラウド環境をプロビジョニングするにはどうすればよいですか。 アプリの機能と更新プログラムを迅速に展開するにはどうすればよいですか。 全体像を丸めるにはどうすればよいでしょうか。

インフラストラクチャに関して広く受け入れられているプラクティスをコードまたは IaC[と](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)して入力します。

IaC を使用すると、プラットフォームのプロビジョニングとアプリケーションの展開を自動化できます。 基本的に、テストやバージョン管理などのソフトウェアエンジニアリングプラクティスを DevOps プラクティスに適用します。 インフラストラクチャとデプロイは、自動化され、一貫性があり、反復可能です。

### <a name="automating-infrastructure"></a>インフラストラクチャの自動化

[Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、terraform、 [Azure CLI](https://docs.microsoft.com/cli/azure/)などのツールを使用すると、必要なクラウドインフラストラクチャを宣言によってスクリプト化することができます。 リソース名、場所、容量、およびシークレットは、パラメーター化され、動的になります。 スクリプトがバージョン管理され、プロジェクトの成果物としてソース管理にチェックインされます。 スクリプトを呼び出して、QA、ステージング、運用などのシステム環境全体で、一貫性のある反復可能なインフラストラクチャをプロビジョニングします。

内部的には、IaC はべき等であり、副作用なしで同じスクリプトを何度も実行できることを意味します。 チームが変更を加える必要がある場合は、スクリプトを編集して再実行します。 更新されたリソースのみが影響を受けます。

「[コードとしてのインフラストラクチャとは](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)」の記事では、作成者 Sam Guckenheimer は、"IaC を実装するチームは、安定した環境を迅速かつ大規模に提供する方法を説明しています。 チームは環境の手動構成を回避し、コードを使用して環境の望ましい状態を表すことによって一貫性を適用します。 IaC を使用したインフラストラクチャのデプロイは反復可能であり、構成のずれや依存関係の不足によって発生するランタイムの問題を回避できます。 DevOps チームは、統合された一連のプラクティスとツールを一緒に使用して、アプリケーションとそのサポートインフラストラクチャを迅速かつ確実に、かつ大規模に配信できます。 "

### <a name="automating-deployments"></a>デプロイの自動化

前に説明した[12 要素アプリケーション](https://12factor.net/)は、完成したコードを実行中のアプリケーションに変換するときに個別の手順を呼び出します。

> *係数 \# 5*は、"各リリースがビルド、リリース、および実行の各段階で厳密な分離を強制する必要があることを指定します。 各には一意の ID をタグ付けし、ロールバックの機能をサポートする必要があります。 "

最新の CI/CD システムは、この原則を満たすのに役立ちます。 個別のデプロイ手順を提供し、ユーザーがすぐに利用できる一貫性のある品質のコードを保証します。

図1-8 は、デプロイプロセス間の分離を示しています。

![CI/CD パイプラインでのデプロイの手順](./media/build-release-run-pipeline.png)

**図 1-8**. CI/CD パイプラインでのデプロイ手順

前の図では、タスクの分離に特に注意を払っています。

開発者は、コード、実行、デバッグの "内側のループ" と呼ばれるものを反復処理して、開発環境で機能を構築します。 完了すると、そのコードは GitHub、Azure DevOps、BitBucket などのコードリポジトリに*プッシュ*されます。

プッシュは、コードをバイナリの成果物に変換するビルドステージをトリガーします。 この作業は、[継続的インテグレーション (CI)](https://martinfowler.com/articles/continuousIntegration.html)パイプラインを使用して実装されます。 アプリケーションのビルド、テスト、およびパッケージ化が自動的に行われます。

リリース段階では、バイナリアーティファクトが取得され、外部のアプリケーションと環境の構成情報が適用され、変更できないリリースが生成されます。 リリースは、指定された環境に配置されます。 この作業は、[継続的デリバリー (CD)](https://martinfowler.com/bliki/ContinuousDelivery.html)パイプラインを使用して実装されます。 各リリースは識別可能である必要があります。 「この配置では、アプリケーションのリリース2.1.1 を実行しています。」と言うことができます。

最後に、リリースされた機能はターゲットの実行環境で実行されます。 リリースは不変であり、すべての変更で新しいリリースを作成する必要があることを意味します。

これらのプラクティスを適用することで、組織はソフトウェアの発送方法を大幅に進化させることができました。 多くの場合、四半期ごとのリリースからオンデマンド更新に移行されました。 目標は、開発サイクルの早い段階で問題を発見して、修正するのが低コストになることです。 統合間の時間が長くなるほど、コストのかかる問題が解決されます。  統合プロセスの一貫性を確保することで、チームはコードの変更をより頻繁にコミットし、コラボレーションとソフトウェアの品質を向上させることができます。

### <a name="azure-pipelines"></a>Azure Pipelines

Azure クラウドには、 [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/)という新しい CI/CD サービスが含まれています。これは、図1-9 に示す[Azure DevOps](https://azure.microsoft.com/services/devops/)オファリングに含まれています。

![DevOps の Azure Pipelines](./media/devops-components.png)

**図 1-9**. Azure DevOps のオファリング

Azure Pipelines は、継続的インテグレーション (CI) と継続的デリバリー (CD) を組み合わせたクラウドサービスです。 コードは、任意のターゲットに対して自動的にテスト、ビルド、および配布できます。

アプリケーションのコードの残りの部分と共に、YAML ファイルのコードでパイプラインを定義します。

- パイプラインは、コードを使用してバージョン管理され、同じ分岐構造に従います。
- プル要求と分岐ビルドポリシーでコードレビューを使用して、変更の検証を行うことができます。
- 使用するすべてのブランチで、azure-pipelines .yml ファイルを変更することによって、ビルドポリシーをカスタマイズできます。
- パイプラインファイルはバージョン管理にチェックインされ、問題がある場合は調査できます。

Azure Pipelines サービスでは、ほとんどの Git プロバイダーがサポートされており、Linux、macOS、または Windows プラットフォームで作成されたアプリケーションのデプロイパイプラインを生成できます。 Java、.NET、JavaScript、Python、PHP、XCode、および C++ のサポートが含まれています。

>[!div class="step-by-step"]
>[前へ](introduction.md)
>[次へ](candidate-apps.md)
