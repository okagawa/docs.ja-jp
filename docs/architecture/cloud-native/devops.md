---
title: DevOps
description: クラウドネイティブアプリケーションの DevOps に関する考慮事項
ms.date: 05/13/2020
ms.openlocfilehash: ce814595245d49e409e780cb0f63c436299c2e4e
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614119"
---
# <a name="devops"></a>DevOps

ソフトウェアコンサルタントのお気に入りのスローガンは、"It が依存している" という質問に回答することです。 ソフトウェアコンサルタントが位置を fond ことはないからです。 ソフトウェアの質問に対する真の答えは1つではないからです。 絶対的な問題はありませんが、正反対間のバランスが必要です。

たとえば、シングルページアプリケーション (spa) とサーバー側アプリケーションの2つの主要な学校で web アプリケーションを開発します。 一方で、ユーザーエクスペリエンスは spa によってより適切になる傾向があり、web サーバーへのトラフィックの量を最小限に抑えることができるので、静的ホストと同じように簡単にホストできます。 一方、SPAs は開発に時間がかかり、テストが困難になる傾向があります。 どれを選択すればよいでしょうか。 それは状況によって異なります。

クラウドネイティブアプリケーションは、同じ dichotomy には対応していません。 開発、安定性、拡張性の面で、明確な利点がありますが、管理はかなり難しくなります。

何年も前に、開発環境から運用環境にアプリケーションを移行するプロセスが1か月以上かかることは珍しくありませんでした。 企業は6か月ごとに、または年ごとにソフトウェアをリリースしました。 Windows 10 の緑色の日前に許容されていたリリースのリズムを調べるために、Microsoft Windows 以外のものを探す必要があります。 Windows XP と Vista の間で5年間 (Vista と Windows 7 の間で3年) が渡されます。

ソフトウェアを迅速にリリースできるように、急速に成長する企業が、sloth のような競合他社よりも大きな市場を獲得できるようになりました。 この理由から、Windows 10 の主要な更新プログラムは約6か月に1回になりました。

より高速で信頼性の高いリリースによってビジネスに価値をもたらすパターンとプラクティスは、総称して DevOps と呼ばれています。 ソフトウェア開発ライフサイクル全体にわたるさまざまなアイデアで構成されており、アプリケーションの配布と運用に至るまで、あらゆる方法でアプリケーションを指定できます。

DevOps はマイクロサービスの前に登場しています。また、運用環境のアプリケーションが1つだけでなく、運用環境のアプリケーションをより簡単に解放して運用できるようにするために、DevOps を使用することによって、より小規模なサービスに移行することはできませんでした。

![図10-1 検索の傾向では、DevOps が非常に明確に確立されるまで、マイクロサービスの拡張が開始されないことがわかります。](./media/microservices-vs-devops.png)

**図 10-1** -DevOps とマイクロサービス。

優れた DevOps プラクティスを利用することで、アプリケーションを実際に運用しているときに、suffocating を使用しなくても、クラウドネイティブアプリケーションの利点を実感することができます。

DevOps に関しては、ゴールデンのハンマーはありません。 高品質のアプリケーションをリリースして運用するための完全で包括的なソリューションを販売することはできません。 これは、各アプリケーションが他のアプリケーションと大幅に異なるためです。 しかし、DevOps を実現するための困難なツールがあります。 これらのツールの1つは、Azure DevOps と呼ばれています。

## <a name="azure-devops"></a>Azure DevOps

Azure DevOps には長い pedigree があります。 Team Foundation Server 最初にオンラインに移行したときと、Visual Studio Online および Visual Studio Team Services のさまざまな名前変更を通じて、ルートをトレースできます。 しかし、長年にわたり、以前よりもはるかに多くのことになりました。

Azure DevOps は、次の5つの主要コンポーネントに分かれています。

![図 10-2 Azure DevOps の5つの主要な領域](./media/devops-components.png)

**図 10-2** -Azure DevOps。

Venerable Team Foundation バージョン管理 (TFVC) と業界のお気に入りの[Git](https://en.wikipedia.org/wiki/Git)をサポートする**Azure Repos**ソースコード管理。 プル要求を使用すると、変更内容を促進に説明することによってソーシャルコーディングを有効にすることができます。

**Azure Boards** -問題と作業項目の追跡ツールを提供します。このツールを使用すると、ユーザーにとって最も効果的なワークフローを選択できます。 これには、スクラムとかんばんスタイルの開発をサポートするためのテンプレートが多数用意されています。

**Azure Pipelines** -Azure との緊密な統合をサポートするビルドおよびリリース管理システム。 ビルドは、Windows から Linux、MacOS まで、さまざまなプラットフォームで実行できます。 ビルドエージェントは、クラウドまたはオンプレミスでプロビジョニングできます。

**Azure Test Plans** -Test Plans 機能によって提供されるテスト管理と探索的テストのサポートにより、QA ユーザーは残されていません。

**Azure Artifacts** -企業が独自の内部バージョンの NuGet、npm、およびその他のバージョンを作成できるようにするアーティファクトフィード。 一元化されたリポジトリで障害が発生した場合に、上流パッケージのキャッシュとして機能するための2つの目的があります。

Azure DevOps の最上位レベルの組織単位は、プロジェクトと呼ばれています。 各プロジェクト内では、Azure Artifacts などのさまざまなコンポーネントをオンまたはオフにできます。 これらの各コンポーネントは、クラウドネイティブアプリケーションに対してさまざまな利点があります。 最も役に立つのは、リポジトリ、ボード、パイプラインの3つです。 ユーザーは、GitHub などの別のリポジトリスタックでソースコードを管理する必要があるが、それでも Azure Pipelines とその他のコンポーネントを利用できる場合は、それが可能です。

さいわい、開発チームはリポジトリを選択するときに多くのオプションを用意しています。 そのうちの1つは GitHub です。

## <a name="github-actions"></a>GitHub のアクション

2009に設立された GitHub は、プロジェクト、ドキュメント、コードをホストするための広く普及している web ベースのリポジトリです。 Apple、Amazon、Google、およびメインストリーム企業など、多くの大規模な技術会社は GitHub を使用しています。 GitHub は、Git という名前のオープンソースの分散型バージョン管理システムを基礎として使用します。 また、各コードベースの欠陥の追跡、機能とプル要求、タスク管理、wiki など、独自の機能セットを追加します。

GitHub の進化に伴って、DevOps 機能が追加されています。 たとえば、GitHub には、と呼ばれる独自の継続的インテグレーション/継続的デリバリー (CI/CD) パイプラインがあり `GitHub Actions` ます。 GitHub アクションは、コミュニティを利用したワークフロー自動化ツールです。 これにより、DevOps チームは既存のツールと統合し、新しい製品を組み合わせて照合し、既存の CI/CD パートナーを含むソフトウェアライフサイクルにフックすることができます。 "

GitHub には4000万を超えるユーザーがいるため、世界中のソースコードの最大のホストになります。 2018年10月に、Microsoft は GitHub を購入しています。 Microsoft は、開発者がプラグインおよび拡張できる[オープンプラットフォーム](https://techcrunch.com/2018/06/04/microsoft-promises-to-keep-github-independent-and-open/)で GitHub を pledged ことができました。 これは、独立した企業として動作し続けます。 GitHub には、enterprise、team、professional、および free アカウントのプランが用意されています。

## <a name="source-control"></a>ソース管理

クラウドネイティブアプリケーションのコードを整理することは困難な場合があります。 1つのジャイアントアプリケーションではなく、クラウドネイティブアプリケーションは、互いに通信する小さなアプリケーションの web で構成される傾向があります。 コンピューティングのすべてのものと同様に、コードの最適な配置は開いている質問のままです。 さまざまな種類のレイアウトを使用する成功したアプリケーションの例がありますが、2つのバリアントは最も人気があると思われます。

実際のソース管理自体に進む前に、適切なプロジェクトの数を決定する価値があります。 1つのプロジェクト内では、複数のリポジトリとビルドパイプラインがサポートされています。 ボードは少し複雑になりますが、1つのプロジェクト内の複数のチームにタスクを簡単に割り当てることができます。 1つの Azure DevOps プロジェクトから、数百、数千もの開発者をサポートすることができます。 これは、すべての開発者が1つの場所で作業を行い、開発者がどのプロジェクトを使用しているかがわからない場合に、1つのアプリケーションを検索する際の混乱を減らすために最適な方法です。

Azure DevOps プロジェクト内のマイクロサービスのコードを分割することは、多少困難な場合があります。

![図10-3 単一または複数のリポジトリ](./media/single-repository-vs-multiple.png)

**図 10-3** -1 つまたは多数のリポジトリ。

### <a name="repository-per-microservice"></a>マイクロサービスごとのリポジトリ

一見すると、これはマイクロサービスのソースコードを分割するための最も論理的なアプローチのように見えます。 各リポジトリには、1つのマイクロサービスを構築するために必要なコードを含めることができます。 このアプローチの利点は、次のとおりです。

1. アプリケーションをビルドして保守するための手順は、各リポジトリのルートにある README ファイルに追加できます。 リポジトリを切り替えると、これらの手順を簡単に見つけることができ、開発者のためのスピンアップ時間が短縮されます。
2. すべてのサービスは論理的な場所に配置され、サービスの名前を知ることで簡単に見つけることができます。
3. ビルドは、所有しているリポジトリに変更が加えられたときにのみトリガーされるように簡単に設定できます。
4. リポジトリに加えられる変更の数は、プロジェクトで作業している少数の開発者に限定されます。
5. セキュリティは、開発者が読み取りと書き込みのアクセス許可を持っているリポジトリを制限することで簡単に設定できます。
6. リポジトリレベルの設定は、所有チームによって変更され、他のユーザーとの議論が少なくて済みます。

マイクロサービスの背後にある主な考え方の1つは、サービスが孤立して互いに分離されている必要があることです。 ドメイン駆動設計を使用してサービスの境界を決定する場合、サービスはトランザクションの境界として機能します。 データベースの更新は複数のサービスにまたがることはできません。 この関連データのコレクションは、境界付けられたコンテキストと呼ばれます。  この考え方は、マイクロサービスデータをデータベースに分離することによって、サービスの残りの部分から独立したものに反映されます。 これにより、ソースコードに至るまで、このアイデアを確実に実行することができます。

ただし、この方法は問題が発生することはありません。 この時間の gnarly 開発の問題の1つは、依存関係の管理です。 平均ディレクトリを構成するファイルの数を考慮してください `node_modules` 。 のような新しいインストールで `create-react-app` は、何千ものパッケージが含まれている可能性があります。 これらの依存関係を管理する方法についての質問は困難です。

依存関係が更新された場合、ダウンストリームパッケージでもこの依存関係を更新する必要があります。 残念ながら、開発作業が必要であるため、ディレクトリには、1つの `node_modules` パッケージの複数のバージョンが含まれており、それぞれが少し異なるリズムでバージョン管理されている他のパッケージの依存関係になっています。 アプリケーションを配置するときは、依存関係のどのバージョンを使用する必要がありますか。 現在運用中のバージョンですか。 現在、ベータ版ですが、コンシューマーが運用環境に作成した時間によって運用環境にある可能性があります。 マイクロサービスを使用するだけでは解決されない困難な問題。

さまざまなプロジェクトに依存しているライブラリがあります。 各リポジトリでマイクロサービスを1つずつ分割することにより、内部的な依存関係を内部リポジトリ、Azure Artifacts を使用して解決することができます。 ライブラリのビルドでは、内部使用のために最新バージョンが Azure Artifacts にプッシュされます。 ダウンストリームプロジェクトは、新しく更新されたパッケージに依存するように手動で更新する必要があります。

サービス間でコードを移動する際には、もう1つの欠点があります。 アプリケーションをマイクロサービスに最初に分割するのは100% であると信じられますが、実際には、サービス部門の間違いを犯すことがないということはほとんどありません。 そのため、機能と、それを駆動するコードは、サービスからサービスに移行する必要があります。リポジトリからリポジトリに移動します。 あるリポジトリから別のリポジトリに今月前進すると、コードの履歴が失われます。 多くの場合、特に監査の場合には、コードの一部を完全に記録することが非常に重要な場合があります。

最終的に最も重要な欠点は、変更の調整です。 実際のマイクロサービスアプリケーションでは、サービス間にデプロイの依存関係はありません。 サービス A、B、および C は、疎結合であるため、任意の順序で展開することができます。 しかし実際には、複数のリポジトリを同時に変更することが望ましい場合もあります。 一部の例には、セキュリティホールを閉じたり、すべてのサービスで使用される通信プロトコルを変更したりするためのライブラリの更新が含まれています。

リポジトリ間の変更を行うには、各リポジトリへのコミットが連続して行われる必要があります。 各リポジトリの各変更は、プル要求され、個別に確認される必要があります。 これは、調整が困難な場合があります。

多くのリポジトリを使用する代わりに、すべてのソースコードを1つのジャイアントにまとめて、単一のリポジトリにまとめることができます。

### <a name="single-repository"></a>1つのリポジトリ

この方法 ( [monorepository](https://danluu.com/monorepo/)とも呼ばれます) では、すべてのサービスのすべてのソースコードが同じリポジトリに格納されます。 一見すると、ソースコードを扱いにくくなる可能性があると考えられます。 ただし、この方法を使用すると、いくつかのマークが付けられています。

1つ目の利点は、プロジェクト間の依存関係の管理が容易になることです。 いくつかの外部成果物フィードを使用するのではなく、プロジェクトを直接インポートできます。 つまり、更新は瞬時に行われ、競合するバージョンは、開発者のワークステーションでコンパイル時に検出される可能性があります。 実際には、一部の統合テストを左にシフトします。

プロジェクト間でコードを移動すると、ファイルは再書き込みではなく移動されたものとして検出されるため、履歴を保存しやすくなりました。

もう1つの利点は、複数のサービス境界を1回のコミットで行うことができるようになることです。 これにより、複数の変更を個別に確認するオーバーヘッドが軽減されます。

コードの静的分析を実行して、セキュリティで保護されていないプログラミング手法や Api の問題のある使用を検出できるツールは多数あります。 マルチリポジトリ環境では、各リポジトリを反復処理して、問題を見つける必要があります。 単一のリポジトリでは、分析をすべて1か所で実行できます。

また、1つのリポジトリアプローチには多くの欠点があります。 1つのリポジトリを持つことで、セキュリティ上の問題が発生します。 リポジトリの内容がサービスモデルあたりのリポジトリでリークした場合、失われるコードの量は最小限になります。 1つのリポジトリを使用すると、会社が所有するすべてのことが失われる可能性があります。 このような場合には多くの例があり、ゲーム開発作業全体を脱線しています。 複数のリポジトリによって公開される領域が少なくなります。これは、ほとんどのセキュリティプラクティスで望ましい特徴です。

1つのリポジトリのサイズは、急速に管理されなくなる可能性があります。 これにより、いくつかの興味深いパフォーマンスの影響が生じます。 特に、Windows チームの開発者のエクスペリエンスを向上させるために設計された、 [Virtual File System For Git などの](https://vfsforgit.org/)特殊なツールを使用することが必要になる場合があります。

多くの場合、1つのリポジトリを使用する引数は、Facebook または Google がソースコードの配置にこのメソッドを使用する引数に分類されます。 これらの企業にとって十分な方法であれば、すべての企業にとって適切なアプローチです。 実際には、いくつかの企業は、Facebook や Google のスケールのようなものを操作します。 これらのスケールで発生する問題は、ほとんどの開発者が直面する問題とは異なります。 Goose は、このような問題には適していない可能性があります。

最後に、いずれかのソリューションを使用して、マイクロサービスのソースコードをホストできます。 ただし、ほとんどの場合、1つのリポジトリで運用するための管理とエンジニアリングのオーバーヘッドは、meager の利点には価値がありません。 複数のリポジトリにコードを分割すると、懸念事項の分離が向上し、開発チーム間の自律性が促進されます。  

### <a name="standard-directory-structure"></a>標準ディレクトリ構造

1つまたは複数のリポジトリに関係なく、各サービスには独自のディレクトリがあります。 開発者がプロジェクト間を迅速に越えることを可能にする最善の最適化の1つは、標準的なディレクトリ構造を維持することです。

![図10-4 電子メールとサインインの両方のサービスの標準的なディレクトリ構造](./media/dir-struct.png)

**図 10-4** -標準的なディレクトリ構造

新しいプロジェクトが作成されるたびに、適切な構造を配置するテンプレートを使用する必要があります。 このテンプレートには、スケルトン README ファイルやなどの便利な項目を含めることもでき `azure-pipelines.yml` ます。 どのマイクロサービスアーキテクチャでも、プロジェクト間の分散が高いほど、サービスに対する一括操作がより困難になります。

複数のソースコードディレクトリを含むディレクトリ全体のテンプレートを提供できる多くのツールがあります。 これは JavaScript の世界で広く普及しており、GitHub は最近リリースされた[リポジトリテンプレート](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/)を使用して、ほぼ同じ機能を提供し[ています](https://yeoman.io/)。

## <a name="task-management"></a>タスク管理

プロジェクト内のタスクの管理は困難な場合があります。 最初に、最適な開発者の生産性を確保するために設定するワークフローの種類に関して、よく寄せられる質問があります。

クラウドネイティブアプリケーションは、従来のソフトウェア製品よりも小さくなる傾向があります。または、少なくとも小さなサービスに分割されています。 これらのサービスに関連する問題またはタスクの追跡は、他のソフトウェアプロジェクトの場合と同様に重要です。 作業項目を追跡したり、問題が適切にログに記録されなかったことを顧客に説明したりする必要はありません。 ボードはプロジェクトレベルで構成されますが、各プロジェクト内では区分を定義できます。 これにより、複数のコンポーネント間で問題を分解できます。 アプリケーション全体のすべての作業を1か所で保持する利点は、作業項目をチームから別のチームに簡単に移動できることです。

Azure DevOps には、多くの一般的なテンプレートが事前構成されています。 最も基本的な構成では、バックログの内容、作業している担当者、および実行されていることを把握しておく必要があります。 重要なのは、ソフトウェアの構築プロセスを可視化することです。これにより、顧客に報告される作業に優先順位を付け、完了したタスクを実行できるようになります。 もちろん、、、およびのように単純なプロセスを実行するソフトウェアプロジェクトはほとんど `to do` `doing` `done` ありません。 この `QA` プロセスには、やなどの手順の追加を開始するのに時間がかかりません `Detailed Specification` 。

アジャイル手法の重要な部分の1つは、定期的に自己イントロスペクションを行うことです。 これらのレビューは、チームが直面している問題とその改善方法についての洞察を提供することを目的としています。 これは、多くの場合、開発プロセスを通じて問題と機能のフローを変更することを意味します。 そのため、追加のステージでボードのレイアウトを拡張するのは非常に健全です。

ボード内のステージは、唯一の組織ツールではありません。 ボードの構成によっては、作業項目の階層が存在します。 ボードに表示できる最も詳細な項目は、タスクです。 既定では、タスクには、タイトル、説明、優先順位、残存作業の量の見積もり、他の作業項目または開発項目 (分岐、コミット、プル要求、ビルドなど) へのリンク機能のフィールドが含まれています。 作業項目は、アプリケーションのさまざまな領域に分類され、イテレーション (スプリント) が異なるため、簡単に見つけることができます。

![図 10-5 Azure DevOps のタスク例](./media/task-details.png)

**図 10-5** -Azure DevOps のタスク

[説明] フィールドでは、期待される標準スタイル (太字、斜体のアンダースコア、取り消し線)、およびイメージを挿入する機能がサポートされます。 これにより、作業またはバグを指定するときに使用できる強力なツールになります。

タスクは、より大きな作業単位を定義する機能にロールアップできます。 さらに、機能は[エピックにロールアップ](https://docs.microsoft.com/azure/devops/boards/backlogs/define-features-epics?view=azure-devops)できます。 この階層でタスクを分類することで、大きな機能をロールアウトする方法を理解しやすくなります。

![図10-6 基本プロセステンプレートで既定で構成されている作業項目の種類](./media/board-issue-types.png)

**図 10-6** -Azure DevOps の作業項目

Azure Boards の問題には、さまざまな種類のビューがあります。 まだスケジュールされていないアイテムは、バックログに表示されます。 そこから、スプリントに割り当てることができます。 スプリントとは、一定の量の作業が完了することが予想される時間ボックスです。 この作業には、タスクだけでなく、チケットの解決も含まれます。 スプリントボードセクションからスプリント全体を管理できます。 このビューには、作業の進行状況が表示されます。また、スプリントが成功するかどうかを確認するためのバーンダウングラフも含まれています。

![図10-7 スプリントが定義されているボード](./media/sprint-board.png)

**図 10-7** -Azure DevOps のボード。

現時点では、Azure DevOps のボードには非常に多くの電力があることが明らかになっています。 開発者にとっては、何が行われているかを簡単に把握できます。 プロジェクトマネージャーが、今後の作業に対するビューや、既存の作業の概要を表示します。 マネージャーに関しては、リソースと容量に関するレポートがたくさんあります。 残念ながら、クラウドネイティブアプリケーションについては、作業を追跡する必要がなくなることはありません。 しかし、作業を追跡する必要がある場合は、Azure DevOps よりもエクスペリエンスが優れている場所がいくつかあります。

## <a name="cicd-pipelines"></a>CI/CD パイプライン

ソフトウェア開発ライフサイクルはほとんど変更されていませんが、継続的インテグレーション (CI) と継続的デリバリー (CD) の登場として革新的になっています。 変更が早期にキャッチされた場合に、プロジェクトのソースコードに対して自動テストをビルドして実行する。 継続的インテグレーションビルドが登場する前は、リポジトリからコードをプルし、テストに合格しなかったか、ビルドできなかったことを確認することは珍しくありません。 この結果、破損のソースが追跡されます。

従来、実稼働環境にソフトウェアを配布するには、広範なドキュメントと手順の一覧が必要でした。 これらの各手順は、エラーが発生しやすいプロセスで手動で完了する必要がありました。

![図10-8 チェックリスト](./media/checklist.png)

**図 10-8** -チェックリスト。

継続的インテグレーションの分割は継続的な配信で、新しく構築されたパッケージは環境に配置されます。 手動プロセスは、開発速度に合わせて拡張できないため、自動化がより重要になります。 チェックリストは、同じタスクを人間よりも速く、より正確に実行できるスクリプトに置き換えられます。

継続的デリバリーが提供する環境は、テスト環境である場合もあれば、多くの主要なテクノロジ企業によって実行される環境である場合もあります。 後者の場合、ユーザーの運用が中断されないという自信を持つ高品質のテストに投資する必要があります。 継続的インテグレーションがコード内の問題を発見した場合と同様に、早い段階での継続的デリバリーでは、デプロイプロセスの問題を早期にキャッチします。

ビルドと配信のプロセスを自動化することの重要性は、クラウドネイティブアプリケーションによって accentuated されています。 展開はより頻繁に行われ、より多くの環境では、境界を手動では不可能な方法で展開します。

### <a name="azure-builds"></a>Azure のビルド

Azure DevOps は、継続的な統合とデプロイをかつてないほど簡単にするための一連のツールを提供します。 これらのツールは Azure Pipelines にあります。 1つ目は、Azure ビルドです。これは、大規模な YAML ベースのビルド定義を実行するためのツールです。 ユーザーは独自のビルドコンピューターを持ち込むことができます (ビルドで慎重を設定する必要がある場合に適しています)。または、Azure でホストされている仮想マシンの継続的に更新されるプールのコンピューターを使用できます。 これらのホストビルドエージェントは、.NET 開発だけでなく、Java から Python、iPhone 開発まで、さまざまな開発ツールで事前インストールされています。

DevOps には、ビルドごとにカスタマイズできる、さまざまなボックスのビルド定義が含まれています。 ビルド定義は、という名前のファイルで定義され、 `azure-pipelines.yml` リポジトリにチェックインされます。これにより、ソースコードと共にバージョン管理されるようになります。 これにより、変更をその分岐にチェックインできるため、ブランチのビルドパイプラインを大幅に変更することが容易になります。 `azure-pipelines.yml`完全なフレームワークで ASP.NET web アプリケーションを構築する例を図10-9 に示します。

```yml
name: $(rev:r)

variables:
  version: 9.2.0.$(Build.BuildNumber)
  solution: Portals.sln
  artifactName: drop
  buildPlatform: any cpu
  buildConfiguration: release
  
pool:
  name: Hosted VS2017
  demands:
  - msbuild
  - visualstudio
  - vstest

steps:
- task: NuGetToolInstaller@0
  displayName: 'Use NuGet 4.4.1'
  inputs:
    versionSpec: 4.4.1

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    restoreSolution: '$(solution)'

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '-p:DeployOnBuild=true -p:WebPublishMethod=Package -p:PackageAsSingleFile=true -p:SkipInvalidConfigurations=true -p:PackageLocation="$(build.artifactstagingdirectory)\\"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: VSTest@2
  displayName: 'Test Assemblies'
  inputs:
    testAssemblyVer2: |
     **\$(buildConfiguration)\**\*test*.dll
     !**\obj\**
     !**\*testadapter.dll
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: CopyFiles@2
  displayName: 'Copy UI Test Files to: $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: UITests
    TargetFolder: '$(build.artifactstagingdirectory)/uitests'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'
    ArtifactName: '$(artifactName)'
  condition: succeededOrFailed()
```

**図 10-9** -.yml のサンプル azure-pipelines

このビルド定義では、複数の組み込みタスクを使用して、大数のセットを作成するのと同じように簡単にビルドを作成できます。 たとえば、NuGet タスクは NuGet パッケージを復元し、VSBuild タスクは Visual Studio build tools を呼び出して実際のコンパイルを実行します。 Azure DevOps には何百ものタスクが用意されており、コミュニティによって管理されています。 どのビルドタスクを実行しようとしているかにかかわらず、だれかが既に構築している可能性があります。

ビルドは手動で、チェックイン、スケジュールに基づいて、または別のビルドの完了によってトリガーできます。 ほとんどの場合、チェックインのたびにビルドすることをお勧めします。 ビルドをフィルター処理して、さまざまなビルドがリポジトリまたは異なる分岐に対して実行されるようにすることができます。 これにより、プル要求に対するテストを減らし、夜間に完全な回帰スイートをトランクに対して実行するなど、高速なビルドを実行するシナリオを実現できます。

ビルドの最終的な結果は、ビルド成果物と呼ばれるファイルのコレクションです。 これらの成果物は、ビルドプロセスの次のステップに従って渡すことも、Azure アーティファクトフィードに追加して、他のビルドで使用することもできます。

### <a name="azure-devops-releases"></a>Azure DevOps のリリース

ビルドでは、ソフトウェアを出荷可能なパッケージにコンパイルする処理を行いますが、継続的デリバリーを完了するには、成果物をテスト環境にプッシュする必要があります。 このため、Azure DevOps はリリースと呼ばれる別のツールを使用します。 リリースツールでは、ビルドで使用できるものと同じタスクライブラリを使用しますが、"ステージ" という概念が導入されています。 ステージは、パッケージがインストールされる分離された環境です。 たとえば、製品は、開発、QA、および運用環境を使用する場合があります。 コードは開発環境に継続的に配信され、自動テストを実行することができます。 これらのテストに合格すると、リリースは手動テストのために QA 環境に移動します。 最後に、コードは運用環境にプッシュされ、だれでも表示できるようになります。

![図10-10 開発、QA、および運用フェーズを含むリリースパイプラインの例](./media/release-pipeline.png)

**図 10-10** -リリースパイプライン

ビルドの各ステージは、前のフェーズの完了時に自動的にトリガーされます。 ただし、多くの場合、これは望ましくありません。 コードを運用環境に移行する場合は、だれからでも承認が必要です。 リリースツールでは、リリースパイプラインの各ステップで承認者を許可することで、これをサポートしています。 特定のユーザーまたはユーザーグループが、運用環境に入る前にリリースでサインオフする必要があるように、ルールを設定できます。 これらのゲートを使用すると、手動による品質チェックを行うことができます。また、運用環境に入る内容を制御するための規制要件に準拠することもできます。

### <a name="everybody-gets-a-build-pipeline"></a>すべての人がビルドパイプラインを取得します

多くのビルドパイプラインを構成するにはコストがかかりません。そのため、マイクロサービスごとに少なくとも1つのビルドパイプラインを用意することをお勧めします。 マイクロサービスはどのような環境にも独立してデプロイできるので、関連のないコードの大部分を解放せずに、それぞれのパイプラインを通じてそれぞれを解放できます。 各パイプラインには、各サービスのビルドプロセスのバリエーションを可能にする独自の承認セットを設定できます。

### <a name="versioning-releases"></a>バージョン管理のリリース

リリース機能を使用する場合の欠点の1つは、チェックインされたファイルで定義できないことです `azure-pipelines.yml` 。 ブランチごとのリリース定義をプロジェクトテンプレートにリリーススケルトンを含めることによって、さまざまな理由が考えられます。 幸いにも、いくつかの段階のサポートをビルドコンポーネントに移行する作業は進行中です。 これは、マルチステージビルドとして知られており、[最初のバージョンが利用可能になりました](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)。

>[!div class="step-by-step"]
>[前へ](azure-security.md)
>[次へ](feature-flags.md)
