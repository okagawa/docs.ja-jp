---
title: アーキテクチャのデプロイ方法 - サーバーレス アプリ
description: エンタープライズ アーキテクチャがクラウドにデプロイされるさまざまな方法のガイド。IaaS、PaaS、コンテナー、サーバーレスを比較します。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: c745a4eb1c6f4a00bf139100b02f31cf3327d01e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "72522728"
---
# <a name="architecture-deployment-approaches"></a>アーキテクチャのデプロイ方法

ビジネス アプリケーションの設計に使用されるアーキテクチャ方法に関係なく、これらのアプリケーションの実装 (デプロイ) はさまざまです。 企業がアプリケーションをホストする先は、物理ハードウェアからサーバーレス機能まであらゆるものがあります。

## <a name="n-tier-applications"></a>n 層アプリケーション

[n 層アーキテクチャ パターン](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/n-tier)は成熟したアーキテクチャであり、さまざまな論理層を別々の物理層に分けるアプリケーションを単に指します。 n 層アーキテクチャとは、n 階層のアーキテクチャを物理的に実装したものです。 このアーキテクチャの最も一般的な実装には、以下が含まれます。

- プレゼンテーション層 (Web アプリなど)。
- API またはデータ アクセス層 (REST API など)。
- データ層 (SQL データベースなど)。

![n 層アーキテクチャ](./media/n-tier-architecture.png)

n 層ソリューションには、以下の特徴があります。

- 通常、プロジェクトは階層と連携しています。
- テストは、階層によって異なる方法を使用できます。
- 階層は抽象レイヤーを示します。たとえば、プレゼンテーション層は通常、データ層の実装の詳細については何も知りません。
- 通常、レイヤーは隣接するレイヤーとのみやりとりします。
- リリースは多くの場合、プロジェクト、従って階層のレベルで管理されます。 単純な API 変更で、中間層全体の新しいリリースが必要になる可能性があります。

この方法には、次のようないくつかの利点があります。

- データベースの分離 (多くの場合、フロントエンドからデータベース バックエンドに直接アクセスできません)。
- API の再利用 (たとえば、モバイル、デスクトップ、Web アプリのクライアントはすべて同じ API を再利用できます)。
- 階層を互いに独立してスケールアウトする機能。
- リファクタリング可能な分離性: 1 つの階層を他の階層に影響を与えることなくリファクタリングできます。

## <a name="on-premises-and-infrastructure-as-a-service-iaas"></a>オンプレミスとサービスとしてのインフラストラクチャ (IaaS)

アプリケーションをホストする従来の方法では、ハードウェアを購入し、オペレーティング システムを含め、すべてのソフトウェア インストールを管理する必要があります。 もともと、高価なデータ センターと物理ハードウェアが必要でした。 物理ハードウェアの運用には、次のように多くの課題があります。

- "万が一" またはピーク需要シナリオに備えて余分に購入する必要がある。
- ハードウェアへの物理的なアクセスをセキュリティで保護する。
- ハードウェア障害 (ディスク障害など) に対する責任。
- 冷却。
- ルーターとロード バランサーの構成。
- 電源の冗長性。
- ソフトウェア アクセスをセキュリティで保護する。

![IaaS の方法](./media/iaas-approach.png)

"仮想マシン" により、ハードウェアを仮想化することで、サービスとしてのインフラストラクチャ (IaaS) が実現します。 ホスト マシンは、専用のメモリ、CPU、およびストレージの割り当てを含むインスタンスにリソースを提供できるように効果的にパーティション分割されます。 チームは必要な VM をプロビジョニングし、関連ネットワークとストレージへのアクセスを構成します。

詳細については、[仮想マシンの n 層参照アーキテクチャ](https://docs.microsoft.com/azure/architecture/reference-architectures/virtual-machines-windows/n-tier)に関するページを参照してください。

仮想化とサービスとしてのインフラストラクチャ (IaaS) は多くの懸念事項に対応しますが、依然として多くの責任がインフラストラクチャ チームの管理下に残ります。 チームは、オペレーティング システムのバージョンを管理し、セキュリティ更新プログラムを適用し、ターゲット マシンにサードパーティの依存関係をインストールします。 多くの場合、アプリの動作は、テスト環境と比較して実稼働コンピューターでは異なります。 さまざまな依存関係のバージョンや OS SKU レベルによって問題が発生します。 多くの組織は n 層アプリケーションをこれらのターゲットにデプロイしますが、多くの企業は、[サービスとしてのプラットフォーム](#platform-as-a-service-paas)のような、よりクラウド ネイティブのモデルにデプロイすることでメリットが得られます。 拡張性と回復性のためにスケールアウトする必要があるため、マイクロサービスを使用したアーキテクチャはより困難になります。

詳細については、[仮想マシン](https://docs.microsoft.com/azure/virtual-machines/)に関するページを参照してください。

## <a name="platform-as-a-service-paas"></a>サービスとしてのプラットフォーム (PaaS)

サービスとしてのプラットフォーム (PaaS) では、開発者が直接接続できるように構成済みのソリューションが提供されます。 PaaS は、マネージド ホスティングを示すもう 1 つの用語です。 基本のオペレーティング システム、セキュリティ パッチ、そして多くの場合サードパーティの依存関係を管理する必要がなくなります。 プラットフォームの例としては、Web アプリケーション、データベース、モバイル バックエンドがあります。

PaaS は、IaaS に共通する課題に対処します。 PaaS を使用すると、開発者は、デプロイ方法ではなく、コードまたはデータベース スキーマに集中できます。 PaaS の利点は次のとおりです。

- アイドル状態のマシンへの投資のオーバーヘッドを排除する使用モデルに対して料金が発生します。
- 直接デプロイと改善された DevOps、継続的インテグレーション (CI)、継続的デリバリー (CD) パイプライン。
- 自動アップグレード、更新プログラム、およびセキュリティ パッチ。
- プッシュボタンのスケールアウトとスケールアップ (エラスティック スケール)。

従来、PaaS の主な欠点はベンダーのロックインでした。 たとえば、一部の PaaS プロバイダーは、ASP.NET、Node.js、またはその他の特定の言語とプラットフォームのみをサポートしています。 Azure App Service などの製品は、複数のプラットフォームに対応し、Web アプリをホストするためのさまざまな言語とフレームワークをサポートするように進化しています。

![サービスとしてのプラットフォーム アーキテクチャ](./media/paas-architecture.png)

## <a name="software-as-a-service-saas"></a>サービスとしてのソフトウェア (SaaS)

サービスとしてのソフトウェア (SaaS) は一元的にホストされ、ローカルのインストールやプロビジョニングなしで利用できます。 SaaS は、多くの場合、ソフトウェアをデプロイするためのプラットフォームとして PaaS の上にホストされます。 SaaS では、既存のソフトウェアを実行して接続するためのサービスを提供します。 SaaS は多くの場合、業界かつ垂直に固有です。 SaaS は多くの場合ライセンスされ、通常はクライアント/サーバー モデルが提供されます。 最新のほとんどの SaaS サービスでは、クライアントを対象とする Web ベースのアプリを使用します。 企業は通常、SaaS をライセンス オファリングのビジネス ソリューションとして検討します。 アプリケーションのスケーラビリティと保守性を目的とするアーキテクチャの考慮事項として実装されることは多くはありません。 実際、ほとんどの SaaS ソリューションは、IaaS、PaaS、サーバーレス バック エンド上に構築されます。

SaaS の詳細については、[サンプル アプリケーション](https://docs.microsoft.com/azure/sql-database/saas-tenancy-welcome-wingtip-tickets-app)を参照してください。

## <a name="containers-and-functions-as-a-service-faas"></a>コンテナーとサービスとしての機能 (FaaS)

コンテナーは、IaaS のオーバーヘッドを発生させることなく、PaaS に似た利点を実現する、興味深いソリューションです。 コンテナーとは、基本的に、一意のアプリケーションの実行に必要な最小限の必要要素を含むランタイムです。 ホスト オペレーティング システムのカーネル (コア部分) とストレージなどのサービスがホスト全体で共有されます。 共有カーネルにより、コンテナーを軽量にできます (通常の仮想マシンのサイズがギガバイトあるのと比べて、ほんのメガバイト単位になるものもあります)。 既に実行されているホストでは、コンテナーをすばやく起動して高可用性を実現できます。 コンテナーをすばやくスピン アップする機能により、回復性のレイヤーも追加されます。 Docker は、コンテナーのより一般的な実装の 1 つです。

コンテナーの利点は次のとおりです。

- 軽量でポータブル
- 自己完結型であるため、依存関係のインストールが不要
- ホストに関係なく一貫した環境を提供 (ノート PC でもクラウド サーバーでもまったく同じ動作)
- スケールアウトのために迅速にプロビジョニング可能
- すぐに再起動して障害から回復可能

コンテナーは、コンテナー ホスト上で実行されます (コンテナー ホストは、ベア メタル マシンまたは仮想マシン上で実行される可能性があります)。 複数のコンテナーまたは同じコンテナーのインスタンスが、1 つのホストで実行される可能性があります。 真のフェールオーバーと回復性を実現するには、コンテナーをホスト間でスケーリングする必要があります。

Docker コンテナーの詳細については、[Docker について](../microservices/container-docker-introduction/docker-defined.md)に関するページを参照してください。

通常、ホスト間でコンテナーを管理するには、Kubernetes などのオーケストレーション ツールが必要です。 オーケストレーション ソリューションを構成して管理すると、プロジェクトのオーバーヘッドが増え、より複雑になる可能性があります。 幸いなことに、多くのクラウド プロバイダーでは、コンテナーの管理を簡略化するために、PaaS ソリューションを通してオーケストレーション サービスを提供しています。

次の図は、Kubernetes のインストール例を示しています。 インストール内のノードで、スケールアウトとフェールオーバーが行われます。 マスター サーバーにより管理される Docker コンテナー インスタンスが実行されます。 "*kubelet*" は、Kubernetes から Docker にコマンドを中継するクライアントです。

![Kubernetes](./media/kubernetes-example.png)

オーケストレーションの詳細については、[Azure Kubernetes](https://docs.microsoft.com/azure/aks/intro-kubernetes) に関するページを参照してください。

サービスとしての機能 (FaaS) は、サーバーレスに似た専用のコンテナー サービスです。 [OpenFaaS](https://github.com/openfaas/faas) と呼ばれる FaaS の固有の実装は、サーバーレス機能を提供するためにコンテナーの上に配置されます。 OpenFaaS には、コードを実行するために必要なコンテナーの依存関係をすべてパッケージ化するテンプレートが用意されています。 テンプレートを使用すると、コードを機能単位としてデプロイするプロセスが簡単になります。 OpenFaaS は、既存のインフラストラクチャを使用できるため、既にコンテナーとオーケストレーターが含まれるアーキテクチャを対象としています。 サーバーレス機能が提供されますが、Docker とオーケストレーターを使用する必要があります。

## <a name="serverless"></a>サーバーレス

サーバーレス アーキテクチャでは、コードとそのホスティング環境が明確に分離されます。 "*トリガー*" によって呼び出される "*関数*" のコードを実装します。 その関数が終了すると、必要なすべてのリソースが解放される可能性があります。 トリガーには、手動、時間指定のプロセス、HTTP 要求、ファイルのアップロードなどがあります。 トリガーの結果、コードが実行されます。 サーバーレス プラットフォームはさまざまですが、ほとんどは、事前定義済みの API とバインドにアクセスして、データベースに書き込む、結果をキューに入れるなどのタスクを効率化できます。

サーバーレスは、コードに集中するためのホスト環境の抽象化に大きく依存するアーキテクチャです。 これは "*サーバーが少ない*" と考えることができます。

コンテナー ソリューションでは、サーバーレス対応のイメージにコードを公開する既存のビルド スクリプトが開発者に提供されます。 その他の実装では、既存の PaaS ソリューションを使用してスケーラブルなアーキテクチャが提供されます。

抽象化は、DevOps チームがサーバーや特定のコンテナーをプロビジョニングまたは管理する必要がないことを意味します。 サーバーレス プラットフォームでは、スクリプトとして、または関連する SDK を使用してビルドされたパッケージ実行可能ファイルとしてコードがホストされ、必要なリソースがスケーリングするコードに割り当てられます。

次の図は、4 つのサーバーレス コンポーネントを示しています。 HTTP 要求により、チェックアウト API コードが実行されます。 チェックアウト API によりコードがデータベースに挿入され、この挿入により、他のいくつかの関数がトリガーされ、タスクの計算や注文の履行などのタスクが実行されます。

![サーバーレス実装](./media/serverless-implementation.png)

サーバーレスの利点は次のとおりです。

- **高密度。** コンテナーまたは仮想マシンと比較して、同じサーバーレス コードの数多くのインスタンスが、同じホスト上で実行できます。 インスタンスは複数のホスト全体でスケール アウトされ、回復性を備えています。
- **マイクロビリング。** ほとんどのサーバーレス プロバイダーは、サーバーレス実行に基づいて課金するため、ある一定のシナリオでは大幅なコスト削減が実現します。
- **インスタント スケール。** サーバーレスは、ワークロードに合わせて自動的かつ迅速にスケーリングすることができます。
- **市場への時間短縮。** 開発者はコードに注力して、サーバーレス プラットフォームに直接デプロイします。 コンポーネントは、互いに独立してリリースできます。

サーバーレスは、ほとんどの場合、コンピューティングの観点で検討されますが、データにも適用できます。 たとえば、[Azure SQL](https://docs.microsoft.com/azure/sql-database) と [Cosmos DB](https://docs.microsoft.com/azure/cosmos-db) はどちらも、ホスト マシンまたはクラスターの構成を必要としないクラウド データベースが提供されます。 この書籍は、サーバーレス コンピューティングに焦点を当てています。

## <a name="summary"></a>まとめ

ハイブリッド方法を含め、アーキテクチャには幅広い選択肢があります。 サーバーレスにより、制御と移植性を犠牲にして、アプリケーション機能の方法、管理、コストが簡略化されます。 ただし、多くのサーバーレス プラットフォームでは、ソリューションを微調整できるように構成が公開されています。 また、適切なプログラミング手法を使用すれば、コードの移植性が高くなり、サーバーレス プラットフォームのロックインが少なくなる可能性があります。 次の表は、アーキテクチャの方法を並べて示しています。 スケーリングのニーズ、ランタイムを管理するかどうか、ワークロードをどの程度小さなコンポーネントに分割できるかに基づいて、サーバーレスを選択します。 次章では、サーバーレスやその他の決定点に関する潜在的な課題について説明します。

|         |IaaS     |PaaS     |コンテナー|サーバーレス|
|---------|---------|---------|---------|----------|
|**拡大縮小**|VM       |インスタンス |アプリ      |Function  |
|**抽象**|ハードウェア|プラットフォーム|OS ホスト|ランタイム   |
|**単位** |VM       |Project  |Image    |コード      |
|**有効期間**|Months|数日から数か月|数分から数日|数ミリ秒から数分|
|**責任**|アプリケーション、依存関係、ランタイム、オペレーティング システム|アプリケーション、依存関係|アプリケーション、依存関係、ランタイム|Function

- **スケール**は、アプリケーションのスケーリングに使用される単位を指します
- **抽象**は、実装によって抽象化されるレイヤーを指します
- **単位**は、デプロイの対象範囲を指します
- **有効期間**は、特定のインスタンスの一般的なランタイムを指します
- **責任**は、アプリケーションをビルド、デプロイ、保守するためのオーバーヘッドを指します

次章では、サーバーレス アーキテクチャ、ユース ケース、および設計パターンに焦点を当てます。

## <a name="recommended-resources"></a>推奨リソース

- [Azure アプリケーション アーキテクチャ ガイド](https://docs.microsoft.com/azure/architecture/guide/)
- [Azure Cosmos DB](https://docs.microsoft.com/azure/cosmos-db)
- [Azure SQL](https://docs.microsoft.com/azure/sql-database)
- [n 層アーキテクチャ パターン](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/n-tier)
- [Azure における Kubernetes](https://docs.microsoft.com/azure/aks/intro-kubernetes)
- [マイクロサービス](https://docs.microsoft.com/azure/architecture/guide/architecture-styles/microservices)
- [仮想マシンの n 層参照アーキテクチャ](https://docs.microsoft.com/azure/architecture/reference-architectures/virtual-machines-windows/n-tier)
- [仮想マシン](https://docs.microsoft.com/azure/virtual-machines/)
- [Docker について](../microservices/container-docker-introduction/docker-defined.md)
- [Wingtip Tickets SaaS アプリケーション](https://docs.microsoft.com/azure/sql-database/saas-tenancy-welcome-wingtip-tickets-app)

>[!div class="step-by-step"]
>[前へ](architecture-approaches.md)
>[次へ](serverless-architecture.md)
