---
title: サーバーレス アーキテクチャ - サーバーレス アプリ
description: Web アプリ、モバイル、および IoT を含む、サーバーレス アーキテクチャでサポートされるさまざまなアーキテクチャとアプリの探索。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: 838dcd7b41df0d8297e1ae10f9c04a8d5b83b332
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "72522409"
---
# <a name="serverless-architecture"></a>サーバーレス アーキテクチャ

[サーバーレス](https://azure.com/serverless) アーキテクチャを使用するアプローチは多数あります。 この章では、サーバーレスを統合する一般的なアーキテクチャの例を探索します。 また、さらに課題をもたらす、あるいはサーバーレスを実装する際に追加の考慮事項が必要となる可能性がある問題が含まれます。 最後に、さまざまなサーバーレスのユース ケースを示す、いくつかの設計例が提供されます。

サーバーレス ホストでは多くの場合、既存のコンテナーベースまたは PaaS レイヤーを使用して、サーバーレス インスタンスを管理します。 たとえば、Azure Functions は [Azure App Service](https://docs.microsoft.com/azure/app-service/) に基づいています。 App Service は、インスタンスをスケールアウトし、Azure Functions コードを実行するランタイムを管理するために使用されます。 Windows ベースの関数の場合、ホストは PaaS として実行され、.NET ランタイムをスケールアウトします。 Linux ベースの関数の場合、ホストではコンテナーを利用します。

![Azure Functions のアーキテクチャ](./media/azure-functions-architecture.png)

WebJobs Core では、関数の実行コンテキストが提供されます。 言語ランタイムではスクリプトを実行し、ライブラリを実行して、対象言語のフレームワークをホストします。 たとえば、JavaScript 関数の実行には Node.js が使用され、C# 関数の実行には .NET Framework が使用されます。 言語とプラットフォームのオプションについては、この章の後半で詳しく学習します。

一部のプロジェクトでは、サーバーレスに "オールイン" アプローチを利用することでメリットが得られる場合があります。 マイクロサービスに大きく依存するアプリケーションでは、サーバーレス テクノロジを使用してすべてのマイクロサービスを実装する場合があります。 ほとんどのアプリはハイブリッドであり、N 層設計に従い、コンポーネントではサーバーレスを使用します。コンポーネントはモジュール型で個別にスケーラブルであるため、理にかなっています。 これらのシナリオを理解するのに役立つように、このセクションではサーバーレスを使用する一般的なアーキテクチャの例についていくつか説明します。

## <a name="full-serverless-back-end"></a>完全なサーバーレス バックエンド

完全なサーバーレス バックエンドは、特に新しいまたは "未開発の" アプリケーションを構築する場合に、いくつかの種類のシナリオに適しています。 API の外部からのアクセス領域が広いアプリケーションでは、各 API をサーバーレス関数として実装することでメリットが得られる場合があります。 マイクロサービス アーキテクチャに基づくアプリは、完全なサーバーレス バックエンドとして実装できるもう 1 つの例です。 マイクロサービスでは、さまざまなプロトコルを介して相互に通信を行います。 具体的なシナリオは次のとおりです。

- API ベースの SaaS 製品 (例: 財政支出プロセッサ)。
- メッセージ駆動型アプリケーション (例: デバイス監視ソリューション)。
- サービス間の統合を重視するアプリ (例: 航空券の予約アプリケーション)。
- 定期的に実行されるプロセス (例: タイマーベースのデータベース クリーンアップ)。
- データ変換を重視するアプリ (例: ファイルのアップロードによってトリガーされるインポート)。
- 抽出、変換、読み込み (ETL) プロセス。

このドキュメントの後半で説明されている、他のより具体的なユースケースがあります。

## <a name="monoliths-and-starving-the-beast"></a>モノリスと "獣を飢えさせる"

一般的な課題は、既存のモノリシック アプリケーションをクラウドに移行することです。 最も危険なアプローチは、仮想マシンに完全に "リフト アンド シフト" することです。 多くの店では、コード ベースを最新化する機会として、移行の利用が好まれます。 移行の実用的なアプローチは "獣を飢えさせる" と呼ばれます。 このシナリオでは、モノリスは最初に "そのまま" 移行されます。 その後、選択されたサービスが最新化されます。 場合によっては、サービスのシグネチャが元のものと同じであることがあります。これは単に関数としてホストされます。 クライアントは、モノリス エンドポイントではなく、新しいサービスを使用するように更新されます。 その間に、データベース レプリケーションなどの手順により、モノリスでトランザクションがまだ処理されている場合でも、マイクロサービスで独自のストレージをホストできるようになります。 最終的には、すべてのクライアントが新しいサービスに移行されます。 すべての機能が置き換えられるまで、モノリスは "飢えた状態" となります (そのサービスが呼び出されなくなる)。 サーバーレスとプロキシの組み合わせによって、この移行の大部分を促すことができます。

![サーバーレス モノリスの移行](./media/serverless-monolith-migration.png)

このアプローチの詳細については、こちらのビデオをご覧ください: [サーバーレスの Azure Functions を使用してアプリをクラウドに持ち込む](https://channel9.msdn.com/Events/Connect/2017/E102)。

## <a name="web-apps"></a>Web アプリ

Web アプリは、サーバーレス アプリケーションに最適です。 現在、Web アプリには、サーバー主導とクライアント主導 (シングル ページ アプリケーション、つまり、SPA など) という 2 つの一般的なアプローチがあります。 サーバー主導の Web アプリでは、通常、ミドルウェア層を使用して API 呼び出しを発行し、Web UI をレンダリングします。 SPA アプリケーションでは、ブラウザーから直接 REST API 呼び出しを行います。 どちらのシナリオでも、サーバーレスでは、必要なビジネス ロジックを提供することにより、ミドルウェアまたは REST API 要求に対応できます。 一般的なアーキテクチャは、軽量の静的な Web サーバーを構築することです。 シングル ページ アプリケーション (SPA) では、HTML、CSS、JavaScript、およびその他のブラウザー資産を提供します。 その後、Web アプリはマイクロサービス バックエンドに接続されます。

## <a name="mobile-back-ends"></a>モバイル バックエンド

サーバーレス アプリのイベント ドリブン パラダイムによって、モバイル バックエンドとして理想的なものになります。 モバイル デバイスによってイベントがトリガーされ、サーバーレス コードが実行されて要求が満たされます。 サーバーレス モデルを利用すると、開発者は完全なアプリケーションの更新プログラムをデプロイすることなく、ビジネス ロジックを強化できます。 また、サーバーレス アプローチでは、チームはエンドポイントを共有し、並列して作業することができます。

モバイル開発者は、サーバー側の専門家にならなくても、ビジネス ロジックを構築することができます。 従来は、モバイル アプリはオンプレミス サービスに接続されていました。 サービス層を構築するには、サーバー プラットフォームとプログラミング パラダイムを理解する必要がありました。 開発者は、サーバーをプロビジョニングして適切に構成するための操作を行いました。 デプロイ パイプラインの構築には、数日あるいは数週間もかかることがありました。 これらすべての課題はサーバーレスで対処されます。

サーバーレスによってサーバー側の依存関係が抽象化され、開発者はビジネス ロジックに集中できます。 たとえば、JavaScript フレームワークを使用してアプリを構築するモバイル開発者は、JavaScript でもサーバーレス関数を構築することができます。 サーバーレス ホストではオペレーティング システム、Node.js インスタンスを管理し、コードのホストや依存関係のパッケージ化などを行います。 開発者には、シンプルな入力セットと、出力用の標準テンプレートが提供されます。 その後、ビジネス ロジックの構築とテストに専念できます。 そのため、既存のスキルを使用して、新しいプラットフォームについて学習したり、"サーバー側の開発者" になったりすることなく、モバイル アプリのバックエンド ロジックを構築することができます。

![サーバーレス モバイル バックエンド](./media/serverless-mobile-backend.png)

ほとんどのクラウド プロバイダーは、モバイル開発ライフサイクル全体を簡略化する、モバイルベースのサーバーレス製品を提供しています。 製品では、データを保持するためのデータベースのプロビジョニングを自動化し、DevOps に関する懸念事項を処理し、クラウドベースのビルドとテスト フレームワークを提供し、開発者の優先言語を使用してビジネス プロセスをスクリプト化できる場合があります。 モバイル中心のサーバーレス アプローチに従うことで、プロセスを効率化できます。 サーバーレスでは、モバイル バックエンド用のサーバーのプロビジョニング、構成、および保守の大きなオーバーヘッドを取り除くことができます。

## <a name="internet-of-things-iot"></a>モノのインターネット (IoT)

IoT は、一緒にネットワーク接続された物理オブジェクトを指します。 "接続されたデバイス" または "スマート デバイス" と呼ばれることもあります。 自動車や自動販売機のすべてが接続され、在庫から温度や湿度などのセンサー データに至る情報が送信される場合があります。 企業では、IoT により、監視と自動化を通じてビジネス プロセスを改善できます。 IoT データを使用して、広い倉庫内の気候を調節したり、サプライ チェーンを通じて在庫を追跡したりする場合があります。 IoT では化学物質流出を感知し、煙が検知されたときに消防署に電話することができます。

多くの場合、莫大な量のデバイスと情報により、メッセージをルーティングして処理するためのイベント ドリブン アーキテクチャが決まります。 サーバーレスは、次のようないくつかの理由で理想的なソリューションです。

- デバイスとデータの量の増加に伴い、スケーリングすることができる。
- 新しいデバイスとセンサーをサポートするための新しいエンドポイントの追加に対応する。
- 独立したバージョン管理を容易にし、開発者がシステム全体をデプロイすることなく、特定のデバイスのビジネス ロジックを更新できるようにする。
- 回復性、およびダウンタイムの削減。

IoT の広汎性により、[Azure IoT Hub](https://docs.microsoft.com/azure/iot-hub)などの IoT の懸念事項に特に焦点を当てる、複数のサーバーレス製品が生成されました。 サーバーレスでは、デバイスの登録、ポリシーの適用、追跡、さらには*エッジ* のデバイスへのコードのデプロイなどのタスクを自動化します。 エッジは、インターネット (ただし、アクティブな部分ではない) に接続されている、センサーやアクチュエータなどのデバイスを指します。

>[!div class="step-by-step"]
>[前へ](architecture-approaches.md)
>[次へ](serverless-architecture-considerations.md)
