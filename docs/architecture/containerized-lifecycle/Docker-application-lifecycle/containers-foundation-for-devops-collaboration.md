---
title: DevOps コラボレーションの基盤としてのコンテナー
description: DevOps を効率化するコンテナーの重要な役割を理解します。
ms.date: 04/16/2020
ms.openlocfilehash: 83bebc92a242a5ac2906d9997b7b278f87f0db96
ms.sourcegitcommit: 1cb64b53eb1f253e6a3f53ca9510ef0be1fd06fe
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/29/2020
ms.locfileid: "82507346"
---
# <a name="containers-as-the-foundation-for-devops-collaboration"></a>DevOps コラボレーションの基盤としてのコンテナー

コンテナーと Docker テクノロジの性質上、開発者は自分のソフトウェアや依存関係を IT 運用や運用環境と容易に共有できると同時に、"自分のコンピューターでは動作する" というよくある言い訳を排除できます。 コンテナーを使用すれば、異なる環境間のアプリケーションの競合を解決できます。 間接的には、コンテナーと Docker により開発者と IT 運用担当はより密接に結びつけられ、両者は効果的なコラボレーションをより簡単に実現できます。 コンテナー ワークフローを採用することで、多くの顧客に DevOps の継続性を提供できます。多くの顧客がこれを求めていましたが、以前はリリース パイプラインおよびビルド パイプライン用のより複雑な構成を介して実装する必要がありました。 DevOps でのビルド/テスト/配置パイプラインはコンテナーにより簡素化されます。

![Docker アプリのライフ サイクルの所有権を示す図。](./media/containers-foundation-for-devops-collaboration/persona-workloads-docker-container-lifecycle.png)

**図 2-1** コンテナー化された Docker アプリケーションのライフサイクルでの "ペルソナ" あたりの主なワークロード

Docker コンテナーでは、コンテナー内にあるもの (アプリケーションとサービス、ならびにフレームワークとコンポーネントに対する依存関係) と、サービスのコレクションで構成されたアプリケーションとしてコンテナーとサービスを一緒に動作させる方法を開発者が所有します。 複数のコンテナーの相互依存関係は、`docker-compose.yml` ファイル、または "*配置マニフェスト*" と呼べるものに定義されます。 一方で、IT 運用チーム (IT プロフェッショナルおよび IT 管理者) は運用環境の管理に集中することができます。それはインフラストラクチャ、スケーラビリティ、監視であり、最終的には、さまざまなコンテナーのコンテンツを把握する必要なく確実にアプリケーションからエンド ユーザーに正しく配信されるようにすることです。 したがって、"コンテナー" という名前は、実世界の出荷用コンテナーとの類似性を思い出させるものです。 要するに、コンテナーの内容物の所有者はコンテナーの出荷方法に関与する必要はなく、運送会社はその内容物について知ることなくまたは気にすることなくコンテナーを発送元から目的地に輸送します。 同様に、開発者は "転送" メカニズムに関与することなく、Docker コンテナー内でコンテンツを作成し所有することができます。

図 2-1 の左側の柱では、開発者が Docker for Windows または Docker for Mac を使用して、Docker コンテナー内でローカルにコードを記述して実行します。 開発者は、実行するベース オペレーティング システムと、コードを Docker イメージにビルドするためのビルド ステップを指定した Dockerfile 使用して、コードの操作環境を定義します。 開発者は、前述の `docker-compose.yml` ファイル配置マニフェストを使用して、1 つまたは複数のイメージを相互運用する方法を定義します。 開発者は、ローカルでの開発が完了すると、そのアプリケーション コードと Docker 構成定ファイルを任意のコード レポジトリ (つまり、Git レポジトリ) にプッシュします。

DevOps の柱では、コード リポジトリに提供された Dockerfile を使用してビルド - 継続的インテグレーション (CI) パイプラインが定義されます。 CI システムでは、選択した Docker レジストリからベース コンテナー イメージが取得され、アプリケーションに合わせてカスタム Docker イメージが作成されます。 次に、そのイメージは検証され、複数の環境への配置を行うために使用する Docker レジストリにプッシュされます。

右側の柱で、運用チームは、運用環境に配置されたアプリケーションとインフラストラクチャを管理しながら、環境とアプリケーションを監視してアプリケーションをどのように改善できるかについてのフィードバックと分析情報を開発チームに提供できるようにします。 コンテナー アプリは通常、[Kubernetes](https://kubernetes.io/) などのコンテナー オーケストレーターを使用して運用環境で実行されます。このとき、通常 docker 構成ファイルではなく、[Helm チャート](https://helm.sh/)を使用してデプロイ ユニットは構成されます。

2 つのチームは、基礎的なプラットフォーム (Docker コンテナー) を介してコラボレーションします。このプラットフォームでは、アプリケーション ライフサイクルにおける 2 つのチームのコラボレーションが大幅に改善されながら、コントラクトとしての懸念事項の分離が実現されます。 開発者はコンテナーのコンテンツ、その運用環境、およびコンテナーの相互依存関係を所有します。一方、運用チームは構築されたイメージとマニフェストを取得し、それらをオーケストレーション システムで実行します。

## <a name="challenges-in-application-life-cycle-when-using-docker"></a>Docker を使用する場合のアプリケーション ライフサイクルの課題。

さまざまな理由から、ここ数年間でコンテナー化されたアプリケーションの数は増えるでしょう。その理由の 1 つとして、マイクロサービスに基づくアプリケーションの作成が挙げられます。

過去 15 年間、Web サービスの使用が数千ものアプリケーションの基盤となってきました。おそらく数年後には、Docker コンテナー上で実行されるマイクロサービスベースのアプリケーションに関して同じ状況が発生するでしょう。

さらに、モノリシック アプリケーションに Docker コンテナーを使用することもでき、その場合も Docker のほとんどの利点が得られるということも言及に値します。 コンテナーでターゲットにされるのは、マイクロサービスだけではありません。

Docker のコンテナー化とマイクロサービスを使用することで、組織の開発プロセスには新たな課題が生じます。そのため、運用システム上で実行される多くのコンテナーおよびマイクロサービスを維持するために強固な戦略が必要です。 最終的に、エンタープライズ アプリケーションでは、数百または数千ものコンテナー/インスタンスが運用環境で実行されることになります。

これらの課題により DevOps ツールを使用する際には新たな要求が生み出されるため、DevOps アクティビティで新しいプロセスを定義し、次のような質問に対する答えを見つける必要があります。

- 開発向けに、また CI/CD、管理、および運用向けにどのようなツールを使用できますか?

- 運用環境で実行する場合、会社はコンテナーでのエラーをどのように管理すればよいですか?

- 運用環境のソフトウェアを最小限のダウンタイムで変更するにはどうすればよいですか?

- 運用システムのスケーリングおよび監視を行うにはどうすればよいですか?

- ご利用のリリース パイプラインにコンテナーのテストと配置を含めるにはどうすればよいですか?

- Microsoft Azure でコンテナー用のオープンソースのツールやプラットフォームを使用するにはどうすればよいですか?

これらのすべての質問に答えることができれば、ご利用のアプリケーション (既存または新規のアプリ) を Docker コンテナーに移動する準備が整います。

## <a name="introduction-to-a-generic-end-to-end-docker-application-life-cycle-workflow"></a>一般的なエンドツーエンドの Docker アプリケーション ライフ サイクル ワークフローの概要

図 2-2 に、Docker アプリケーション ライフサイクルの詳細なワークフローを示します。このインスタンスでは、特定の DevOps アクティビティと資産に重点を置いています。

![Docker アプリの汎用的なエンドツーエンド ライフ サイクルを示す図。](./media/containers-foundation-for-devops-collaboration/generic-end-to-enddpcker-app-life-cycle.png)

**図 2-2** Docker でコンテナー化されたアプリケーション ライフ サイクルのワークフローの概要

すべてのものは開発者から始まります。開発者は、内側のループのワークフローでコードの記述を開始します。 内側のループのステージでは、開発者はコード リポジトリ (たとえば、Git などのソース管理システム) にコードをプッシュする前に発生するすべてのことを定義します。 それがコミットされると、リポジトリによって継続的インテグレーション (CI) とその他のワークフローがトリガーされます。

内側のループは基本的に "コード化"、"実行"、"テスト"、"デバッグ" のような典型的なステップと、アプリをローカルで実行する直前に必要な追加のステップで構成されています。 これは、開発者が担当するプロセスであり、アプリを Docker コンテナーとして実行してテストします。 内側のループのワークフローについては、以降のセクションで説明します。

エンドツーエンドのワークフローを振り返ってみると、DevOps ワークフローは単なるテクノロジまたはツールセットではありません。文化的な進化を必要とする考え方になります。 アプリケーションのライフ サイクルをより速く、より予測可能にするのは、人、プロセス、そして適切なツールです。 コンテナー化されたワークフローを採用する企業は、通常、コンテナー化されたワークフローに対応する人とプロセスを実現するために組織を再構築します。

DevOps の実践では、エラーが発生しやすい手動プロセスを自動化に置き換えて、トレーサビリティの向上と繰り返し可能なワークフローを実現して、チームが一体となって競争上の圧力に迅速に対応できるように支援します。 組織はまた、オンプレミスとクラウドのリソースの組み合わせると共に緊密に統合されたツールを使用して、環境をより効率的に管理し、コスト削減を実現することができます。

Docker アプリケーション用に DevOps ワークフローを実装する場合、Docker テクノロジがワークフローのほぼすべてのステージに存在することがわかります。それは、内側のループ (コード、実行、デバッグ) で機能する開発ボックスから、ビルド-テスト-CI フェーズ、そして最後はステージングおよび運用環境へのそれらのコンテナーの配置に至ります。

品質プラクティスを改善することは、開発サイクルで早期に欠陥を識別して修正コストを削減するのに役立ちます。 環境と依存関係をイメージに含めて、複数の環境に同じイメージを配置するという理念を採用することにより、環境固有の構成を抽出して配置をより信頼性の高いものにするという規範を促進します。

効果的なインストルメンテーション (監視と診断) を通じて得られた豊富なデータからは、パフォーマンス上の問題とユーザーの行動に関する分析情報が提供され、将来の優先順位と投資を決めるためのガイドとなります。

DevOps は目的地ではなく道のりと見なすべきです。 これは、成功を実証し、学習し、そして進化することができる適切にスコープ化されたプロジェクトを通して段階的に実装される必要があります。

## <a name="benefits-of-devops-for-containerized-applications"></a>コンテナー化されたアプリケーションに対する DevOps の利点

堅実な DevOps ワークフローから得られる最も重要な利点のいくつかを次に示します。

- より高品質のソフトウェアをより速く、より高いコンプライアンスで提供できます。

- 継続的な改善と調整をより早く、より経済的に推進できます。

- ソフトウェアの提供と運用に関わる関係者間の透明性とコラボレーションを向上させることができます。

- セキュリティリスクを最小限に抑えながら、コストを管理し、プロビジョニングされたリソースをより効果的に利用できます。

- オープンソースへの投資を含む、既存の DevOps 投資の多くと十分にプラグ アンド プレイすることができます。

>[!div class="step-by-step"]
>[前へ](index.md)
>[次へ](../Microsoft-platform-tools-containerized-apps/index.md)
