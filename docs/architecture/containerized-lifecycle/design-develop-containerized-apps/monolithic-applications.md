---
title: モノリシック アプリケーション
description: モノリシック アプリケーションのコンテナー化の中心概念を理解します。
ms.date: 02/15/2019
ms.openlocfilehash: 3c186f6a300588816916886927f93e0c06ebd6bc
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988987"
---
# <a name="monolithic-applications"></a>モノリシック アプリケーション

このシナリオでは、1 つのモノリシックな Web アプリケーションまたはサービスを構築し、それをコンテナーとして展開します。 アプリケーション内の構造はモノリシックではなく、複数のライブラリ、コンポーネント、さらにはレイヤー (アプリケーション レイヤー、ドメイン レイヤー、データアクセス レイヤーなど) を含む場合があります。 これは外部的には、単一のプロセス、単一の Web アプリケーション、または単一のサービスなど、単一のコンテナーです。

このモデルを管理するには、アプリケーションを表す単一のコンテナーを展開します。 これを拡大するには、ロード バランサーを前面に配置してコピーをいくつか追加します。 単一のコンテナーまたは仮想マシン (VM) の単一の展開を管理すればよいので、単純です。

コンテナーは 1 つのことのみを、1 つのプロセスで実行するというコンテナーの原則に従えば、モノリシックのパターンとは矛盾します。 図 4-1 に示すように、各コンテナーには複数のコンポーネント/ライブラリ、または内部レイヤーを含めることができます。

![アプリを複製してスケールアウトするモノリシック アプリを示す図。](./media/monolithic-applications/monolithic-application-architecture-example.png)

**図 4-1** モノシリック アプリケーションのアーキテクチャ例

モノシリック アプリでは、その機能のすべてまたはほとんどが、1 つのプロセスまたはコンテナーにあり、内部レイヤーやライブラリにコンポーネント化されています。 このアプローチの欠点は、アプリケーションが大きくなり、スケーリングする必要が出てきた場合に明らかになります。 アプリケーション全体がスケーリングすれば、実際には問題ではありません。 しかし、ほとんどの場合、スケーリングの必要性があるネックの部分はアプリケーションの一部であり、他のコンポーネントはそれほど使用されていません。

一般的な eコマースを例にとると、スケーリングする必要が生じるのは多くの場合、製品情報のコンポーネントです。 製品を購入するユーザーよりも多くのユーザーが製品を参照します。 より多くの顧客が、支払いパイプラインではなくバスケットを使用します。 コメントを追加したり、購入履歴を表示したりする顧客はそれほどいません。 また、単一のリージョンで、コンテンツとマーケティング キャンペーンを管理する必要がある従業員数はおそらくほんの一握りです。 モノリシック デザインをスケーリングすると、コード全体が複数回展開されます。

"すべてをスケーリングする" 問題に加えて、1 つのコンポーネントを変更した場合、アプリケーション全体を完全に再テストし、すべてのインスタンスを完全に再展開する必要があります。

モノリシック アプローチは一般的であり、多くの組織がこのアーキテクチャ メソッドを使用して開発を行っています。 多くのユーザーは十分な結果を得ていますが、他のユーザーは限界を感じています。 多くの組織は、このモデルでアプリケーションを設計していました。これは、ツールとインフラストラクチャでは SOA の構築が非常に困難だったため、および、アプリケーションが大きくなるまでその必要性がわからなかったためです。

インフラストラクチャの観点から説明すると、図 4-2 に示すように、リソースの効率的な受け入れ可能な使用量の割合内で、各サーバーは同じホスト内で多数のアプリケーションを実行できます。

![別々のコンテナーに複数のアプリがある 1 つのホストを示す図。](./media/monolithic-applications/host-with-multiple-apps-containers.png)

**図 4-2** 複数のアプリ/コンテナーを実行しているホスト

最後に、可用性の観点から考えた場合、モノリシック アプリケーションをデプロイする場合、全体をデプロイする必要があります。つまり、デプロイ期間中に、*停止および起動*する必要がある場合、すべての機能とすべてのユーザーが影響を受けます。 図 4-3 のとおり、特定の状況では、Azure とコンテナーの使用でこれらの状況を最小限に抑えることができ、アプリケーションをダウンさせる可能性を減らすことができます。

Azure にモノリシック アプリケーションをデプロイするには、各インスタンスに専用の VM を使用します。 [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/) を使用すると、VM のスケーリングを簡単に行うことができます。

また [Azure App Service](https://azure.microsoft.com/services/app-service/) では、VM の管理を必要とせずに、モノリシック アプリケーションを実行し、インスタンスを簡単にスケーリングすることができます。 Azure App Services では、Docker コンテナーの単一インスタンスも実行できるため、デプロイが簡単になります。

複数の VM を Docker のホストとしてデプロイして、VM ごとに任意の数のコンテナーを実行することができます。 次に、図 4-3 に示すように、Azure Load Balancer を使用することにより、スケーリングを管理できます。

![モノリシック アプリが異なるホストにスケールアウトされていることを示す図。](./media/monolithic-applications/multiple-hosts-from-single-docker-container.png)

**図 4-3** 1 つの Docker アプリケーションをスケールアウトする複数のホスト

ホスト自体のデプロイを、従来のデプロイ手法を使用して管理できます。

`docker run` および `docker-compose up` などのコマンドを使用して、コマンドラインから Docker コンテナーを管理できます。また、継続的デリバリー (CD) パイプラインで自動化し、たとえば Azure DevOps Services から Docker ホストにデプロイすることもできます。

## <a name="monolithic-application-deployed-as-a-container"></a>コンテナーとして展開するモノリシック アプリケーション

モノリシックの展開の管理にコンテナーを使用する利点があります。 コンテナーのインスタンスをスケーリングする処理は、追加の VM を展開するよりもはるかに高速で簡単です。

更新プログラムを Docker イメージとして展開する方がはるかに高速で、ネットワークの効率が高くなります。 通常、Docker コンテナーは数秒で起動するので、高速にロールアウトできます。 Docker コンテナーの破棄は、`docker stop` コマンドの発行と同じくらい簡単で、通常は 1 秒未満で完了します。

コンテナーは設計上、本質的に変更不可であるため、更新スクリプトが、ディスク上に残された特定の構成またはファイルを考慮しない場合があるため、VM の破損については心配する必要がありません。

モノリシック アプリケーションでは Docker の利点を得られますが、ここではその利点の一部のみに触れています。 コンテナー管理のそれよりも大きな利点は、コンテナー オーケストレーターを使用する展開によるものです。コンテナー オーケストレーターは、各コンテナー インスタンスのさまざまなインスタンスとライフサイクルを管理します。 モノリシック アプリケーションを、スケーリング、開発、および展開を個別に実行できるサブシステムに分割することが、マイクロサービスの領域への入り口になります。

コンテナーを使用してモノリシック アプリケーションを “リフト アンド シフト” する方法および、アプリケーションを最新化する方法については、Microsoft のこの追加のガイド「[Azure クラウドおよび Windows コンテナーを使用して既存の .NET アプリケーションを最新化する](../../modernize-with-azure-containers/index.md)」を参照してください。これは、<https://aka.ms/LiftAndShiftWithContainersEbook> から PDF でダウンロードすることも可能です。

## <a name="publish-a-single-docker-container-app-to-azure-app-service"></a>Azure App Service への 1 つの Docker コンテナー アプリの発行

Azure にデプロイしたコンテナーを迅速に検証する場合でも、またはアプリが単なる単一のコンテナー アプリの場合でも、Azure App Service には、スケーラブルな単一のコンテナーベースのサービスを提供できる優れた方法があります。

Azure App Service は直感的に使用でき、起動してすぐに実行することができます。これは、コードを取得し Microsoft Visual Studio でビルドして Azure に直接デプロイするための Git との優れた統合が提供されているためです。 しかし、従来 (Docker を使用しない場合)、App Services でサポートされていないその他の機能、フレームワークまたは依存関係が必要であった場合、Azure チームがそれらの依存関係を App Service で更新するまで待つか、ユーザーがさらに制御でき、使用しているアプリケーションで必要なコンポーネントやフレームワークをインストールできる Service Fabric、Cloud Services、または単純な VM に切り替える必要がありました。

さて、図 4-4 に示すように、Visual Studio 2017 を使用する場合、Azure App Service のコンテナー サポートにより、アプリケーション環境に必要なものをすべて含めることができます。 お使いのアプリに依存関係を追加した場合、それをコンテナー内で実行しているため、それらの依存関係を Dockerfile または Docker イメージに含めることができるようになります。

![Container Registry が表示される [App Service の作成] ダイアログのスクリーンショット。](./media/monolithic-applications/publish-azure-app-service-container.png)

**図 4-4** Visual Studio のアプリ/コンテナーから Azure App Service へのコンテナーの発行

図 4-4 では、発行フローでイメージが Container Registry を介してプッシュされているのも示しています。これは、Azure Container Registry (Azure のデプロイの近くの、Azure Active Directory グループとアカウントによってセキュリティで保護されているレジストリ)、または Docker Hub やオンプレミス レジストリなどのその他の Docker レジストリにすることもできます。

>[!div class="step-by-step"]
>[前へ](common-container-design-principles.md)
>[次へ](state-and-data-in-docker-applications.md)
