---
title: ラッパー コードの保護
description: ラッパーコードをセキュリティで保護する方法を確認します。これにより、特にラッパーがそれを使用するコードよりも高い信頼を持つ場合は、セキュリティの脆弱性の固有のセットを開くことができます。
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
ms.openlocfilehash: 4338b3d0ab306501ea252407f386bdf89d191d6d
ms.sourcegitcommit: 0fa2b7b658bf137e813a7f4d09589d64c148ebf5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/14/2020
ms.locfileid: "86309379"
---
# <a name="securing-wrapper-code"></a>ラッパー コードの保護
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 ラッパー コードで、使用しているコードよりもラッパーの信頼が高い場合には特に、特有のセキュリティ脆弱性が生じる恐れがあります。 呼び出し元の制限されたアクセス許可が適切なセキュリティ チェックに含まれないと、呼び出し元のために実行されるすべての処理が、悪用される可能性のある潜在的な脆弱性となります。  
  
 呼び出し元自体で実行できない処理をラッパーによって行うことがないようにしてください。 完全なスタック ウォーク要求とは対照的に、限定的なセキュリティ チェックしか行われずに何らかの処理が行われる場合に、この状況は特に危険です。 単一レベルのチェックが行われる場合、実際の呼び出し元と対象の API 要素との間にラッパー コードを挿入することによって、本来は成功すべきではないセキュリティ チェックが簡単に成功してしまう原因となる可能性があり、セキュリティが弱体化します。  
  
## <a name="delegates"></a>代理人  
 デリゲートのセキュリティは、.NET Framework のバージョンによって異なります。  このセクションでは、各種デリゲートの動作と、関連するセキュリティ上の考慮事項について説明します。  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a>.NET Framework バージョン 1.0 および 1.1 の場合  
 .NET Framework バージョン 1.0 および 1.1 は、デリゲートの作成者とデリゲートの呼び出し元に対して、次のセキュリティ アクションを実行します。  
  
- デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
- デリゲートが呼び出されると、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
 ご使用のコードで <xref:System.Delegate> を取得するときに、それを呼び出すことができる信頼性の低いコードから取得する場合には、その信頼性の低いコードによってアクセス許可がエスカレートされることがないようにしてください。 デリゲートを取得して後ほど使用するとき、デリゲートを作成したコードは呼び出しスタック上にはなく、デリゲートのコードまたはデリゲートを行うコードが保護された操作を試みる場合にアクセス許可がテストされないことになります。 ご使用のコードと呼び出し元のコードに作成者よりも高い特権がある場合、作成者は呼び出しスタックの一部になることなく、呼び出しパスを編成できます。  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a>バージョン2.0 およびそれ以降のバージョンの .NET Framework  
 以前のバージョンとは異なり、バージョン 2.0 .NET Framework 以降のバージョンでは、デリゲートが作成されて呼び出されたときに、デリゲートの作成者に対してセキュリティアクションが実行されます。  
  
- デリゲートが作成されると、デリゲート対象メソッドのセキュリティ リンク要求が、デリゲート作成者の許可セットに対して実行されます。  セキュリティ アクションを満たすことができないと、<xref:System.Security.SecurityException> が結果として生じます。  
  
- デリゲート作成時に、デリゲート作成者の許可セットも取得され、デリゲートと一緒に格納されます。  
  
- デリゲートが呼び出されると、デリゲート作成者と呼び出し元が属するアセンブリが異なる場合には、現在のコンテキストの任意の要求に対して、デリゲート作成者の取得された許可セットが最初に評価されます。  次に、デリゲート呼び出し元の既存のセキュリティ要求が実行されます。  
  
## <a name="link-demands-and-wrappers"></a>リンク要求とラッパー  
 リンク要求に関する特別な保護がセキュリティ インフラストラクチャで強化されましたが、依然としてコード内で脆弱性の原因となる可能性があります。  
  
 完全に信頼されたコードが[linkdemand](link-demands.md)によって保護されているプロパティ、イベント、またはメソッドを呼び出す場合、呼び出し元に対する**linkdemand**権限チェックが満たされると、呼び出しは成功します。 さらに、完全に信頼されたコードが、プロパティの名前を受け取り、その**get**アクセサーをリフレクションを使用して呼び出すクラスを公開する場合、ユーザーコードにこのプロパティにアクセスする権限がない場合でも、 **get**アクセサーへの呼び出しは成功します。 これは、 **LinkDemand**が完全に信頼されたコードである直接の呼び出し元だけをチェックするためです。 基本的に、完全に信頼できるコードは、ユーザー コードに代わって呼び出す権限があり、その際、ユーザー コードに呼び出すための権限があるかどうかの確認は行いません。  
  
 このようなセキュリティホールを防ぐために、共通言語ランタイムは、 **LinkDemand**によって保護されたメソッド、コンストラクター、プロパティ、またはイベントに対する間接呼び出しに対する完全なスタックウォーク要求に対して、チェックを拡張します。 この保護により若干のパフォーマンス コストが発生し、セキュリティ チェックのセマンティクスが変更されます。より高速な単一レベルのチェックに合格していた場合にも完全なスタック ウォーク要求が失敗する可能性があります。  
  
## <a name="assembly-loading-wrappers"></a>アセンブリ読み込みラッパー  
 マネージド コードの読み込みに使用されるいくつかのメソッド (<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> など) は、呼び出し元の証拠に基づいてアセンブリを読み込みます。 これらのメソッドのいずれかをラップする場合、セキュリティ システムがアセンブリを読み込むとき、ラッパーに対する呼び出し元のアクセス許可ではなく、ご使用のコードのアクセス許可を使用できることがあります。 信頼度の低いコードが、呼び出し元のより高いアクセス許可がラッパーに付与されているコードを読み込むことを許可しないでください。  
  
 完全な信頼のあるコード、または潜在的な呼び出し元 (インターネット アクセス許可レベルの呼び出し元など) よりも信頼が高いコードであっても、こうした方法でセキュリティが弱体化する可能性があります。 コードに、バイト配列を受け取り、それを**アセンブリ**に渡すパブリックメソッドがある場合、呼び出し元に代わってアセンブリを作成すると、セキュリティが損なわれる可能性があります。  
  
 この問題は、次の API 要素に当てはまります。  
  
- <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
- <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a>Demand とLinkDemand  
 宣言型のセキュリティでは、類似しているが異なるチェックを実行する2種類のセキュリティチェックが提供されます。 どちらのフォームも理解しておくことをお勧めします。誤って選択すると、セキュリティが脆弱になり、パフォーマンスが低下する可能性があるためです。  
  
 宣言型のセキュリティには、次のセキュリティ チェックがあります。  
  
- <xref:System.Security.Permissions.SecurityAction.Demand> はコード アクセス セキュリティのスタック ウォークを指定します。 スタック上の各呼び出し元が合格するには、指定のアクセス許可または ID が必要です。 スタックには異なる呼び出し元が含まれている可能性があるため、すべての呼び出しで**要求**が発生します。 メソッドを繰り返し呼び出す場合は、このセキュリティ チェックが毎回行われます。 **要求**は、おとり攻撃に対する適切な保護です。不正なコードを取得しようとしていることが検出されます。  
  
- [LinkDemand](link-demands.md)はジャストインタイム (JIT) コンパイル時に発生し、直前の呼び出し元だけをチェックします。 このセキュリティ チェックでは、呼び出し元の呼び出し元はチェックされません。 このチェックに合格すると、呼び出し元が何度も呼び出す場合であってもさらにセキュリティ オーバーヘッドが生じることはありません。 ただし、おびき寄せによる攻撃からの保護機能はありません。 **LinkDemand**を使用すると、テストに合格してコードを参照できるすべてのコードは、承認されたコードを使用して悪意のあるコードからを呼び出すことができるため、セキュリティが損なわれる可能性があります。 したがって、可能性のあるすべての弱点を完全に回避できる場合を除き、 **LinkDemand**は使用しないでください。  
  
    > [!NOTE]
    > .NET Framework 4 では、リンク確認要求はアセンブリの属性に置き換えられてい <xref:System.Security.SecurityCriticalAttribute> <xref:System.Security.SecurityRuleSet.Level2> ます。 は、 <xref:System.Security.SecurityCriticalAttribute> 完全信頼のリンク確認要求に相当します。ただし、継承規則にも影響します。 この変更の詳細については、「[透過的セキュリティコード、レベル 2](security-transparent-code-level-2.md)」を参照してください。  
  
 **LinkDemand**を使用する場合に必要な追加の注意事項は、個別にプログラミングする必要があります。セキュリティシステムは、適用に役立ちます。 どのようなミスもセキュリティを脆弱化します。 作成したコードを使用する、承認されたすべてのコード側で、次の措置を行うことによって追加セキュリティを実装する責任があります。  
  
- 呼び出し元のコードがクラスまたはアセンブリにアクセスするのを制限します。  
  
- 呼び出されるコードに現れる呼び出し元のコードで同じセキュリティ チェックを配置し、呼び出し元にその実行義務を課します。 たとえば、フラグが指定されたの**linkdemand**で保護されたメソッドを呼び出すコードを記述する場合、 <xref:System.Security.Permissions.SecurityPermission> メソッドは <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> このアクセス許可に対して**linkdemand** (または、より強力な**要求**) を作成する必要があります。 例外は、コード内の他のセキュリティ保護メカニズム (要求など) を使用して、コードで**LinkDemand**によって保護されたメソッドを使用する場合に、安全であると判断された場合に発生します。 前述の例外的なケースでは、呼び出し側で、基になるコードでのセキュリティ保護の脆弱性に対処する必要があります。  
  
- 呼び出し元のコードが、呼び出し先のコードに成り代わって、保護されているコードを呼び出すことがないようにしてください。 つまり、呼び出し元は承認されたコードに対して、保護されているコードに特定のパラメーターを渡したり、結果を送り返させたりすることはできません。  
  
### <a name="interfaces-and-link-demands"></a>インターフェイスとリンク要求  
 **LinkDemand**を持つ仮想メソッド、プロパティ、またはイベントが基底クラスのメソッドをオーバーライドする場合は、有効にするために、基底クラスのメソッドにも、オーバーライドされたメソッドに対して同じ**LinkDemand**が必要です。 悪意のあるコードが、基本型にキャスト バックを行い、基本クラスのメソッドを呼び出す可能性があります。 リンク要求を、<xref:System.Security.AllowPartiallyTrustedCallersAttribute> アセンブリ レベル属性を持たないアセンブリに暗黙的に追加できるという点にも注意してください。  
  
 インターフェイス メソッドでリンク要求も指定されている場合は、メソッドの実装をリンク要求で保護するのは良い方法です。 リンク要求をインターフェイスと一緒に使用する場合、以下の点に注意してください。  
  
- インターフェイスメソッドを実装するクラスのパブリックメソッドに**linkdemand**を配置した場合、そのインターフェイスにキャストしてメソッドを呼び出すと、 **linkdemand**は適用されません。 この場合、インターフェイスにリンクしているため、インターフェイスの**LinkDemand**だけが受け入れられます。  
  
 セキュリティの問題に関して次の項目をレビューします。  
  
- インターフェイス メソッドでのリンク要求を明示的に指定します。 こうしたリンク要求が期待どおりの保護を提供することを確認します。 悪意のあるコードがキャストを使用して、前述のようにリンク要求を迂回できるかどうかを判別します。  
  
- リンク要求が適用される仮想メソッド。  
  
- 実装する型とインターフェイス。 一貫してリンク要求を使用する必要があります。  
  
## <a name="see-also"></a>関連項目

- [安全なコーディングのガイドライン](../../standard/security/secure-coding-guidelines.md)
