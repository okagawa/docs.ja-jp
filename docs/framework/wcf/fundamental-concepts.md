---
title: Windows Communication Foundation の基本概念
description: この概要については、Windows Communication Foundation (WCF) アーキテクチャの基礎について説明します。
ms.date: 03/30/2017
helpviewer_keywords:
- WCF [WCF], concepts
- concepts [WCF]
- fundamentals [WCF]
- Windows Communication Foundation [WCF], concepts
ms.assetid: 3e7e0afd-7913-499d-bafb-eac7caacbc7a
ms.openlocfilehash: 93e75942487a1a81a8b0e8ecd8d9d666610152dc
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/23/2020
ms.locfileid: "85244675"
---
# <a name="fundamental-windows-communication-foundation-concepts"></a>Windows Communication Foundation の基本概念

このドキュメントでは、Windows Communication Foundation (WCF) アーキテクチャの概要について説明します。 ここでは、主要概念およびこれらの概念がどのように組み合わされているかについて説明します。 WCF サービスとクライアントの最も単純なバージョンを作成するためのチュートリアルについては、[はじめにチュートリアル](getting-started-tutorial.md)を参照してください。 WCF プログラミングの詳細については、「[基本的な Wcf プログラミング](basic-wcf-programming.md)」を参照してください。

## <a name="wcf-fundamentals"></a>WCF の基礎

WCF は、サービスとクライアント間でメッセージを送信するシステムを作成するためのランタイムおよび一連の Api です。 同じコンピューター システム上、または別の企業内にあり、インターネット経由でアクセスするシステム上の他のアプリケーションと通信するアプリケーションを作成する場合にも、同じインフラストラクチャと API が使用されます。

### <a name="messaging-and-endpoints"></a>メッセージングとエンドポイント

WCF は、メッセージベースの通信の概念に基づいています。メッセージとしてモデル化できるもの (HTTP 要求やメッセージキュー (MSMQ) メッセージなど) は、プログラミングモデルで一貫した方法で表すことができます。 これにより、さまざまなトランスポート機構にわたり統一された API が実現します。

このモデルは、通信を開始するアプリケーションである_クライアント_と、クライアントが通信してその通信に応答するのを待機するアプリケーションである_サービス_を区別します。 1 つのアプリケーションがクライアントとサービスの両方の役割を果たすことができます。 例については、「[双方向サービス](./feature-details/duplex-services.md)」および「[ピアツーピアネットワーク](./feature-details/peer-to-peer-networking.md)」を参照してください。

メッセージは、エンドポイント間で送信されます。 _エンドポイント_は、メッセージが送受信される場所 (またはその両方) であり、メッセージ交換に必要なすべての情報が定義されています。 サービスは、1 つ以上のアプリケーション エンドポイント (および 0 個以上のインフラストラクチャ エンドポイント) を公開し、クライアントは、サービスのエンドポイントのいずれかと互換性のあるエンドポイントを作成します。

_エンドポイント_は、メッセージの送信方法、メッセージの送信方法、メッセージの表示方法など、標準的な方法で記述されます。 サービスは、クライアントが適切な WCF クライアントと通信_スタック_を生成するために処理できるメタデータとしてこの情報を公開できます。

### <a name="communication-protocols"></a>通信プロトコル

通信スタックに必要な要素の1つに、_トランスポートプロトコル_があります。 一般的なトランスポート (HTTP や TCP など) を使用して、イントラネットおよびインターネット上でメッセージを送信できます。 メッセージ キュー アプリケーションおよびピア ネットワーク メッシュのノードとの通信をサポートする他のトランスポートも含まれます。 WCF の組み込みの拡張ポイントを使用して、さらに多くのトランスポートメカニズムを追加できます。

通信スタックのもう 1 つの必須要素はエンコードです。エンコードは、特定のメッセージをどのように書式設定するかを指定します。 WCF には、次のエンコーディングが用意されています。

- テキスト エンコード。相互運用可能なエンコードです。

- MTOM (Message Transmission Optimization Mechanism) エンコード。これは、サービスとの間で構造化されていないバイナリ データを効率的に送信するための相互運用可能な方法です。

- バイナリ エンコード。このエンコードを使用すると、転送を効率的に行うことができます。

WCF の組み込みの拡張ポイントを使用して、エンコードメカニズム (圧縮エンコードなど) を追加できます。

### <a name="message-patterns"></a>メッセージ パターン

WCF は、要求/応答、一方向、双方向通信など、いくつかのメッセージングパターンをサポートしています。 各種トランスポートがサポートするメッセージング パターンはそれぞれに異なるため、サポートされる対話の種類に影響します。 WCF Api とランタイムは、メッセージを安全かつ確実に送信するのにも役立ちます。

## <a name="wcf-terms"></a>WCF の用語

WCF ドキュメントで使用されるその他の概念と用語を次に示します。

**メッセージ**  
 独立したデータ単位は、本文やヘッダーなどの複数の部分で構成できます。

**サービス**  
 1 つ以上のエンドポイントを公開する構造体です。各エンドポイントは、1 つ以上のサービス操作を公開します。

**エンドポイント**  
 メッセージを送信または受信 (または送受信) する場所となる構造体です。 これは、メッセージの送信先を定義する場所 (アドレス)、メッセージを送信する方法を説明する通信機構 (バインディング) の仕様、およびその場所 (サービスコントラクト) で送信できるメッセージを記述するメッセージのセット (またはその両方) の定義で構成されます。

WCF サービスは、エンドポイントの集まりとして外部に公開されます。

**アプリケーションエンドポイント**  
 アプリケーションによって公開されるエンドポイントです。アプリケーション エンドポイントは、アプリケーションで実装されるサービス コントラクトに対応しています。

**インフラストラクチャエンドポイント**  
 サービス コントラクトに関連しないサービスで必要とされる機能または提供される機能を促進するために、インフラストラクチャによって公開されるエンドポイントです。 たとえば、サービスは、メタデータ情報を提供するインフラストラクチャ エンドポイントを持つ場合があります。

**アドレス**  
 メッセージを受信する場所を指定します。 アドレスは、URI (Uniform Resource Identifier) として指定されます。 URI のスキーマ部分では、そのアドレスに到達するために使用するトランスポート機構 (HTTP、TCP など) を指定します。 URI の階層部分には一意の場所が含まれ、その形式はトランスポート機構によって異なります。

エンドポイント アドレスにより、サービスのエンドポイントごとに一意のエンドポイント アドレスを作成できます。また、一定の条件下では、エンドポイント間でアドレスを共有することもできます。 既定以外のポートで HTTPS プロトコルを使用するアドレスの例を次に示します。

```http
HTTPS://cohowinery:8005/ServiceModelSamples/CalculatorService
```

**関連付け**  
 エンドポイントが外部と通信する方法を定義します。 バインディングは、バインド要素と呼ばれる一連のコンポーネントで構成されます。各バインド要素を "積み重ねる" ことで、通信インフラストラクチャが作成されます。 バインディングでは、少なくともトランスポート (HTTP や TCP など) と使用するエンコード (テキストやバイナリなど) が定義されます。 バインディングには、メッセージをセキュリティで保護するために使用するセキュリティ機構や、エンドポイントが使用するメッセージ パターンなどの詳細を指定したバインディング要素を含めることができます。 詳細については、「[サービスの構成](configuring-services.md)」を参照してください。

**バインド要素**  
 バインディングの特定の部分 (トランスポート、エンコード、インフラストラクチャ レベルのプロトコル (WS-ReliableMessaging など) の実装、通信スタックのその他のコンポーネントなど) を表します。

**ビヘイビアー**  
 サービス、エンドポイント、特定の操作、またはクライアントの実行時のさまざまな状況を制御するコンポーネントです。 動作はスコープに従ってグループ化されます。共通動作は、すべてのエンドポイントにグローバルに作用し、サービス動作は、サービスに関連する側面にのみ作用します。また、エンドポイントの動作は、エンドポイントに関連するプロパティにのみ作用し、操作レベルの動作は特定の操作に作用します。 たとえば、サービス動作の 1 つである調整では、メッセージの数が多すぎて処理しきれないおそれがある場合に、サービスでどのように対処するかを指定します。 一方、エンドポイントの動作は、セキュリティ資格情報の検索方法や検索場所など、エンドポイントに関連する側面だけを制御します。

**システム指定のバインディング**  
 WCF には、システム指定のバインディングが多数用意されています。 これらは、特定のシナリオ用に最適化されたバインディング要素の集まりです。 たとえば、は、 <xref:System.ServiceModel.WSHttpBinding> さまざまな WS 仕様を実装するサービスとの相互運用性を確保するように設計されてい \* ます。 これらの定義済みバインディングでは、特定のシナリオに適切に適用できるオプションだけが提供されるため、時間を節約できます。 定義済みバインディングが要件を満たさない場合は、独自のカスタム バインドを作成できます。

**構成とコーディング**  
 アプリケーションは、コーディング、構成、またはこの 2 つの組み合わせによって制御できます。 構成には、コードの作成後、再コンパイルを必要とせずに、開発者以外のユーザー (ネットワーク管理者など) がクライアントとサービスのパラメーターを設定できるという利点があります。 構成では、エンドポイント アドレスなどの値を設定できるだけでなく、エンドポイント、バインディング、および動作の追加が可能であるため、制御を強化することもできます。 コーディングの場合、開発者はサービスまたはクライアントのすべてのコンポーネントに対する厳密な制御を保持できます。構成によって行われた設定を検査し、必要に応じてコードによってオーバーライドできます。

**サービス操作**  
 操作の機能を実装するためにサービスのコードに定義された手順です。 この操作は、WCF クライアントのメソッドとしてクライアントに公開されます。 メソッドは、値を返すこともあれば、任意の数の引数を受け取ることもあります。また、引数を受け取らず、応答を返さないこともあります。 たとえば、単純な "Hello" という機能を持つ操作をクライアントの存在の通知として使用したり、一連の操作を開始するために使用したりできます。

**サービスコントラクト**  
 関連する複数の操作を 1 つの機能単位に関連付けます。 コントラクトでは、サービスの名前空間や対応するコールバック コントラクトなど、サービス レベルの設定を定義できます。 ほとんどの場合、開発者が選択したプログラミング言語でインターフェイスを作成し、このインターフェイスに <xref:System.ServiceModel.ServiceContractAttribute> 属性を適用することによって、コントラクトを定義します。 実際のサービス コードは、インターフェイスを実装することによって作成されます。

**操作のコントラクト**  
 操作コントラクトは、操作のパラメーターと戻り値の型を定義します。 サービス コントラクトを定義するインターフェイスの作成時に、コントラクトに含まれる各メソッド定義に <xref:System.ServiceModel.OperationContractAttribute> 属性を適用することによって、操作コントラクトを表します。 各操作は、単一のメッセージを取得し、単一のメッセージを返すようにモデル化することも、一連の型を取得し、型を返すようにモデル化することもできます。 後者の場合、その操作用に交換する必要のあるメッセージの形式がシステムによって決定されます。

**メッセージコントラクト**  
 メッセージの形式を記述します。 たとえば、メッセージ要素をヘッダーと本文のどちらに入れるか、メッセージのどの要素にどのレベルのセキュリティを適用するかなどを宣言します。

**エラーコントラクト**  
 サービス操作に関連付けることにより、呼び出し元に返すことのできるエラーを示すことができます。 操作には、0 個以上のエラーを関連付けることができます。 これらのエラーは、プログラミング モデルで例外としてモデル化される SOAP エラーです。

**データコントラクト**  
 サービスが使用するデータ型のメタデータの記述。 これにより、他のサービスをそのサービスと相互運用できます。 このデータ型は、パラメーターや戻り値など、メッセージの任意の部分で使用することができます。 サービスが単純型だけを使用している場合、データ コントラクトを明示的に使用する必要はありません。

**ホスティング**  
 サービスは、何らかのプロセス内でホストされている必要があります。 _ホスト_とは、サービスの有効期間を制御するアプリケーションです。 サービスは、自己ホスト型であっても、既存のホスティング プロセスによって管理されていてもかまいません。

**自己ホスト型サービス**  
 開発者が作成したプロセス アプリケーション内で実行されるサービスです。 開発者は、サービスの有効期間を制御し、サービスのプロパティを設定します。また、サービスを開き (サービスをリッスン モードに設定する)、サービスを閉じることも開発者が行います。

**ホストプロセス**  
 サービスをホストするように設計されたアプリケーションです。 ホスティング プロセスには、インターネット インフォメーション サービス (IIS)、Windows アクティブ化サービス (WAS)、Windows サービスなどがあります。 これらのホスト シナリオでは、ホストがサービスの有効期間を制御します。 たとえば、IIS を使用して、サービス アセンブリや構成ファイルを格納する仮想ディレクトリを設定できます。 メッセージを受信すると、IIS はサービスを開始し、その有効期間を制御します。

**インスタンス化**  
 サービスには、インスタンス化モデルが含まれます。 インスタンス化モデルには、1 つの CLR オブジェクトがすべてのクライアントにサービスを提供する "単一モデル"、クライアント呼び出しを処理するために、呼び出しごとに新しい CLR オブジェクトが作成される "呼び出しモデル"、CLR オブジェクトのセットがセッションごとに 1 つ作成される "セッション モデル" の 3 つのモデルがあります。 インスタンス化モデルの選択は、アプリケーション要件とサービスの予想される使用パターンによって異なります。

**クライアントアプリケーション**  
 1 つ以上のエンドポイントとメッセージを交換するプログラムです。 クライアント アプリケーションは、WCF クライアントのインスタンスを作成し、WCF クライアントのメソッドを呼び出すことによって開始されます。 1 つのアプリケーションがクライアントとサービスの両方として機能できることに注意してください。

**チャネル**  
 バインド要素の具象実装です。 バインディングは構成を表し、チャネルはその構成に関連付けられた実装です。 したがって、各バインディング要素に関連付けられたチャネルが存在します。 チャネルが積み重ねられて、バインディングの具象実装 (チャネル スタック) が作成されます。

**WCF クライアント**  
 サービス操作をメソッドとして公開するクライアントアプリケーションコンストラクト (Visual Basic や Visual C# など、任意の .NET Framework プログラミング言語)。 サービスをホストするアプリケーションも含め、すべてのアプリケーションが WCF クライアントをホストできます。 したがって、他のサービスの WCF クライアントを含むサービスを作成できます。

[ServiceModel メタデータユーティリティツール (Svcutil.exe)](servicemodel-metadata-utility-tool-svcutil-exe.md)を使用して WCF クライアントを自動的に生成し、メタデータを公開する実行中のサービスでポイントすることができます。

**Metadata**  
 サービスで、外部エンティティがそのサービスと通信するために認識しておく必要のあるサービスの特性を示します。 [ServiceModel メタデータユーティリティツール (Svcutil.exe)](servicemodel-metadata-utility-tool-svcutil-exe.md)では、メタデータを使用して、クライアントアプリケーションがサービスとの対話に使用できる WCF クライアントと付随する構成を生成できます。

サービスが公開するメタデータには、サービスのデータ コントラクトが定義された XML スキーマ ドキュメントと、サービスのメソッドが記載された WSDL ドキュメントが含まれます。

メタデータを有効にすると、WCF によってサービスとそのエンドポイントが検査され、サービスのメタデータが自動的に生成されます。 サービスからメタデータを公開するには、メタデータの動作を明示的に有効にする必要があります。

**セキュリティ**  
 WCF には、機密性 (盗聴を防ぐためのメッセージの暗号化)、整合性 (メッセージの改ざんを検出するための手段)、認証 (サーバーとクライアントを検証するための手段)、承認 (リソースへのアクセスの制御) が含まれます。 これらの関数は、TLS over HTTP (HTTPS とも呼ばれます) などの既存のセキュリティメカニズムを利用するか、またはさまざまな WS-SECURITY 仕様の1つ以上を実装することによって提供され \* ます。

**トランスポートセキュリティモード**  
 トランスポート層の機構 (HTTPS など) によって、機密性、整合性、および認証を提供することを示します。 HTTPS のようなトランスポートを使用する場合、このモードには、パフォーマンスの面で効率的であることと、インターネットで普及しているため、十分に認識されているという利点があります。 欠点は、この種のセキュリティは通信パスの各ホップで個別に適用されるため、通信が "Man-in-the-middle" 攻撃の影響を受けやすくなることです。

**メッセージセキュリティモード**  
 [Web Services Security: SOAP メッセージセキュリティ](http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0.pdf)という名前の仕様など、1つまたは複数のセキュリティ仕様を実装することによってセキュリティを提供することを指定します。 各メッセージには、メッセージ送信中のセキュリティを確保し、受信側による改ざんの検出とメッセージの復号化を可能にするために必要な機構が含まれます。 この意味で、セキュリティはすべてのメッセージ内にカプセル化されるため、複数のホップにわたるエンド ツー エンドのセキュリティが実現します。 セキュリティ情報はメッセージの一部になるため、メッセージと共に複数の種類の資格情報を含めることもできます (これらは_要求_と呼ばれます)。 この方法には、送信元と送信先の間の複数のトランスポートを含め、どのトランスポート上でもメッセージを安全に送信できるという利点もあります。 この方法の欠点は、使用される暗号化機構が複雑であるため、パフォーマンスに影響することです。

**メッセージ資格情報を使用したトランスポートセキュリティモード**  
 トランスポート層を使用してメッセージの機密性、認証、および整合性を提供します。各メッセージには、メッセージの受信側で必要とされる複数の資格情報 (クレーム) を含めることができます。

**JAX-WS\***  
 WCF に実装された一連の Web サービス (WS) 仕様 (WS-Security や WS-ReliableMessaging など) の略称です。

## <a name="see-also"></a>関連項目

- [Windows Communication Foundation とは](whats-wcf.md)
- [Windows Communication Foundation のアーキテクチャ](architecture.md)
