---
title: エラー処理
ms.date: 03/30/2017
ms.assetid: c948841a-7db9-40ae-9b78-587d216cbcaf
ms.openlocfilehash: f6c0d676a37648678b2b726a46a6238ccc1b3331
ms.sourcegitcommit: eff6adb61852369ab690f3f047818c90580e7eb1
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/07/2019
ms.locfileid: "72004887"
---
# <a name="error-handling-in-windows-communication-foundation-wcf"></a>Windows Communication Foundation でのエラー処理 (WCF)

サービスで予期しない例外やエラーが発生した場合、例外処理ソリューションを設計する方法は複数あります。 1つの "適切" または "ベストプラクティス" のエラー処理ソリューションはありませんが、1つの考慮すべき有効なパスが複数あります。 通常は、次のリストの複数のアプローチを組み合わせるハイブリッドソリューションを実装することをお勧めします。これは、WCF 実装の複雑さ、例外の種類と頻度、処理されたものと処理されていない性質によって異なります。例外と、関連するトレース、ログ、またはポリシーの要件。

これらのソリューションについては、このセクションの残りの部分で詳しく説明します。

## <a name="the-microsoft-enterprise-library"></a>Microsoft Enterprise Library

Microsoft Enterprise Library Exception Handling Application Block は、共通の設計パターンを実装し、エンタープライズ アプリケーションのすべてのアーキテクチャ レイヤーで発生する例外を処理するための一貫した戦略を策定するのに役立ちます。 これは、アプリケーション コンポーネントの catch ステートメントに含まれる一般的なコードをサポートするように設計されています。 開発者は、アプリケーション全体で同一の catch ブロックにこのコード (例外情報をログに記録するコードなど) を繰り返し使用する代わりに、Exception Handling Application Block を使用すると、このロジックを再利用可能な例外ハンドラーとしてカプセル化できます。

このライブラリには、すぐに使用できる Fault Contract Exception Handler が含まれています。 この例外ハンドラーは、WCF サービスの境界で使用するように設計されており、例外から新しいエラーコントラクトを生成します。

アプリケーション ブロックは、よく使用されるベスト プラクティスを組み込み、アプリケーション全体の例外処理に共通の方法を提供することを目的としています。 その一方で、独自に開発されたカスタム エラー ハンドラーやエラー コントラクトが非常に便利な場合もあります。 たとえば、カスタムエラーハンドラーを使用すると、すべての例外を FaultExceptions に自動的に昇格させ、ログ記録機能をアプリケーションに追加することができます。

詳細については、 [Microsoft Enterprise Library](https://docs.microsoft.com/previous-versions/msp-n-p/ff632023(v=pandp.10))を参照してください。

## <a name="dealing-with-expected-exceptions"></a>予期される例外の処理

適切な対処方法は、すべての操作または関連する拡張ポイントで予期される例外をキャッチし、それらを回復できるかどうかを判断して、FaultException\<T > に適切なカスタムエラーを返すことです。
  
## <a name="dealing-with-unexpected-exceptions-using-an-ierrorhandler"></a>IErrorHandler を使用した予期しない例外の処理

予期しない例外に対処するには、IErrorHandler の "フック" を行うことをお勧めします。 エラーハンドラーは、チャネルレイヤーではなく、WCF ランタイムレベル ("サービスモデル" レイヤー) でのみ例外をキャッチします。 チャネル レベルで IErrorHandler をフックする唯一の方法は、カスタム チャネルを作成することです。ただし、これはほとんどのシナリオで推奨されていません。

"予期しない例外" は、通常、回復不可能な例外でも処理の例外でもありません。その代わりに、予期しないユーザー例外が発生します。 回復不可能な例外 (メモリ不足の例外など) は、通常、[サービスモデル例外ハンドラー](xref:System.ServiceModel.Dispatcher.ExceptionHandler)によって自動的に処理されますが、通常は正常に処理されません。このような例外を処理する唯一の理由は、追加のログを記録するか、標準の例外をクライアントに返すことです。 処理例外は、シリアル化、エンコーダー、フォーマッタ レベルなどのメッセージの処理中に発生します。通常、この例外は IErrorHandler では処理できません。これは、一般的に、このような例外が発生するまでにエラー ハンドラーの介入が早すぎるか、遅すぎることが原因です。 同様に、トランスポート例外も IErrorHandler では処理できません。

IErrorHandler を使用すると、例外がスローされたときのアプリケーションの動作を明示的に制御できます。 次のような操作が可能です。  

1. クライアントにエラーを送信するかどうかを決定します。

2. 例外をエラーに置き換えます。

3. エラーを別のエラーに置き換えます。

4. ログ記録またはトレースを実行します。

5. その他のカスタムアクティビティを実行します。

カスタム エラー ハンドラーは、サービスのチャネル ディスパッチャーの ErrorHandlers プロパティに追加することでインストールできます。  複数のエラー ハンドラーを設定することができ、これらはこのコレクションに追加された順序で呼び出されます。

IErrorHandler.ProvideFault は、クライアントに送信されるエラー メッセージを制御します。 このメソッドは、サービスの操作によってスローされた例外の種類に関係なく呼び出されます。 ここで操作を実行しない場合、WCF は既定の動作を想定し、カスタムエラーハンドラーが配置されていないかのように続行します。

この方法を使用する可能性がある場合として、クライアントに送信される前の例外をエラーに変換するための一元的な場所を作成する場合があります (インスタンスが破棄されておらず、チャネルが Faulted 状態に移行していないことを確認します)。

IErrorHandler メソッドは、通常、エラーログ、システム通知、アプリケーションのシャットダウンなどのエラー関連の動作を実装するために使用されます。IErrorHandler は、サービス内の複数の場所で呼び出すことができます。また、エラーがスローされた場所によっては、HandleError メソッドが操作と同じスレッドによって呼び出されないこともあります。この点については保証されません。

## <a name="dealing-with-exceptions-outside-wcf"></a>WCF 以外の例外の処理

多くの場合、構成の例外、データベース接続文字列の例外、およびその他の同様の例外は、WCF アプリケーションのコンテキスト内で発生する可能性がありますが、これらの例外自体は、サービス モデルまたは Web サービス自体が原因で発生する例外ではありません。 これらの例外は、web サービス外部の "通常の" 例外であり、環境内の他の外部例外を処理する場合と同様に処理する必要があります。

## <a name="tracing-exceptions"></a>例外のトレース

トレースは、すべての例外が表示される可能性のある唯一の "キャッチオール" の場所です。 例外のトレースとログの詳細については、「トレースとログ」を参照してください。

## <a name="uri-template-errors-when-using-webgetattribute-and-webinvokeattribute"></a>WebGetAttribute と WebInvokeAttribute を使用した場合の URI テンプレート エラー

WebGet 属性と WebInvoke 属性を使用すると、要求アドレスのコンポーネントを操作パラメーターにマップする URI テンプレートを指定できます。 たとえば、URI テンプレートが "weather/{state}/{city}" の場合は、要求アドレスがリテラル トークン、state という名前のパラメーター、および city という名前にマップされます。 その後、これらのパラメーターは、名前によって、操作の仮パラメーターの一部にバインドされる場合があります。

テンプレート パラメーターが URI 内の文字列の形式で表されるのに対し、型指定されたコントラクトの仮パラメーターは文字列以外の型である可能性があります。 そのため、操作が呼び出される前に変換を行う必要があります。 [変換形式のテーブル](wcf-web-http-programming-model-overview.md)を使用できます。

ただし、変換に失敗した場合は、失敗したことを操作に認識させる方法はありません。 代わりに、型変換は、ディスパッチ エラーの形式で表示されます。

型変換のディスパッチ エラーは、エラー ハンドラーをインストールすることで、その他多くの種類のディスパッチ エラーと同様に調査できます。 IErrorHandler 機能拡張ポイントは、サービス レベルの例外を処理するために呼び出されます。 そこから、呼び出し元に返される応答を選択できます (カスタム タスクとレポートを実行することもできます)。

## <a name="see-also"></a>参照

- [基本的な WCF プログラミング](../basic-wcf-programming.md)
