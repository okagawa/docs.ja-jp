---
title: DNX から .NET Core CLI への移行
description: DNX ツールの使用から .NET Core CLI ツールの使用に移行します。
ms.date: 06/20/2016
ms.openlocfilehash: 31317f110ae1e8586b78becd757d0a8ff07f1459
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "77503821"
---
# <a name="migrating-from-dnx-to-net-core-cli-projectjson"></a>DNX から .NET Core CLI への移行 (project.json)

## <a name="overview"></a>概要
NET Core と ASP.NET Core 1.0 の RC1 リリースでは、DNX ツールが導入されました。 NET Core と ASP.NET Core 1.0 の RC2 リリースでは、DNX から .NET Core CLI に移行しました。

補足情報として、DNX とは何であったのかを要約します。 DNX は、ランタイムであると共に、.NET Core (具体的には ASP.NET Core 1.0 アプリケーション) を構築するために使用するツールセットでした。 おもに次の 3 つの部分で構成されていました。

1. DNVM - DNX を取得するためのインストール スクリプト
2. DNX (Dotnet 実行ランタイム) - コードを実行するランタイム
3. DNU (Dotnet 開発者ユーティリティ) - 依存関係の管理、アプリケーションの構築および発行のためのツール

CLI の導入により、上記のすべてが単一のツールセットに含められました。 ただし、RC1 タイム フレームでは DNX が提供されていたので、ご使用のプロジェクトは DNX を使用して構築されている可能性があります。その場合は、新しい CLI ツールに移行する必要があります。

この移行ガイドでは、DNX からと .NET Core CLI にプロジェクトを移行する方法の要点を説明します。 プロジェクトを一から .NET Core で始める場合は、このドキュメントは自由にスキップできます。

## <a name="main-changes-in-the-tooling"></a>ツールの主な変更
まずツールの全般的な変更点をいくつか説明しておく必要があります。

### <a name="no-more-dnvm"></a>DNVM の終了
DNVM (*DotNet Version Manager* の略) は、コンピューターに DNX をインストールするための bash/PowerShell スクリプトでした。 DNVM を使用することにより、ユーザーは自分で指定したフィード (または既定のフィード) から必要な DNX を容易に取得することができ、さらに、特定のセッションで $PATH にプッシュされるように特定の DNX に "アクティブ" マークを付けることができました。 これがあれば、さまざまなツールを使用できます。

.NET Core CLI に加えられた変更によって DNVM の機能セットが冗長になったため、DNVM は廃止されました。

CLI は、主に次の 2 つの方法でパッケージ化されています。

1. 特定のプラットフォームのネイティブ インストーラー
2. その他の状況 (CI サーバーなど) に対応するインストール スクリプト

そのため、DNVM の機能のインストールは必要ありません。 しかし、ランタイム選択機能はどうでしょうか?

`project.json` 内でランタイムを参照するには、特定のバージョンのパッケージを依存関係に追加します。 この変更により、アプリケーションは新しいランタイム コンポーネントを使用できるようになります。 これらのコンポーネントをコンピューターに組み込む方法は、CLI の場合と同じです。サポートされているネイティブ インストーラーのいずれか、またはインストール スクリプトを使用してランタイムをインストールします。

### <a name="different-commands"></a>種々のコマンド
DNX の場合、一部のコマンドについては 3 つのパート (DNX、DNU、DNVM) のいずれかから使用していました。 CLI になって、これらのコマンドの一部は変更され、一部は使用できなくなり、一部は同じであるがセマンティクスが若干異なる状況となりました。

次の表では、DNX/DNU コマンドと、対応する CLI コマンドのマッピングを示します。

| DNX コマンド                    | CLI コマンド    | [説明]                                                                                                     |
|--------------------------------|----------------|-----------------------------------------------------------------------------------------------------------------|
| dnx run                        | `dotnet run`     | ソースからコードを実行します。                                                                                           |
| dnu build                      | `dotnet build`   | コードの IL バイナリをビルドします。                                                                                |
| dnu pack                       | `dotnet pack`    | コードの NuGet パッケージをパッケージ化します。                                                                        |
| dnx \[command] ("dnx web" など) | 適用なし\*          | DNX の環境では、project.json 内の定義に従ってコマンドを実行します。                                                     |
| dnu install                    | 適用なし\*          | DNX の環境では、パッケージを依存関係としてインストールします。                                                            |
| dnu restore                    | `dotnet restore` | project.json に指定された依存関係を復元します。 ("[注を参照](#dotnet-restore-note)")                                                            |
| dnu publish                    | `dotnet publish` | 展開対象のアプリケーションを 3 つの形式 (ポータブル、ネイティブ アプリ、スタンドアロン) のいずれかで発行します。 |
| dnu wrap                       | 適用なし\*          | DNX の環境では、csproj で project.json をラップします。                                                                    |
| dnu commands                   | 適用なし\*          | DNX の環境では、インストールされたコマンドをグローバルに管理します。                                                           |

(\*) - これらの機能は、CLI では設計上サポートされていません。

## <a name="dnx-features-that-are-not-supported"></a>サポートされていない DNX 機能
上表に示すように、DNX 環境の機能の中には、少なくとも当面の間、CLI でサポートしないことに決定した機能があります。 このセクションでは、その中で最も重要なものを取り上げ、それらのサポートを中止した論理的根拠と、必要になった場合の解決策について概説します。

### <a name="global-commands"></a>グローバル コマンド
DNU には、"グローバル コマンド" と呼ばれる概念が採用されています。 これらは基本的に、NuGet パッケージとしてパッケージ化されたコンソール アプリケーションであり、指定された DNX を呼び出してアプリケーションを実行するシェル スクリプトが含まれていました。

CLI では、この概念をサポートしていません。 しかし、使い慣れた `dotnet <command>` 構文を使用して呼び出し可能なプロジェクトごとのコマンドを追加する、という概念はサポートされています。

### <a name="installing-dependencies"></a>依存関係のインストール
v1 の時点で、.NET Core CLI には依存関係をインストールするための `install` コマンドが用意されていません。 NuGet からパッケージをインストールするには、該当するパッケージを依存関係として `project.json` ファイルに追加し、`dotnet restore` を実行する必要があります ([注記参照](#dotnet-restore-note))。

### <a name="running-your-code"></a>コードの実行
コードを実行する方法は、主に 2 つあります。 1 つは、`dotnet run` を使用してソースから実行する方法です。 この方法では、`dnx run` の場合とは異なり、メモリ内のコンパイルを行いません。 `dotnet build` を実際に呼び出すことで、コードをビルドし、ビルドされたバイナリを実行します。

もう 1 つは、`dotnet` 自体を使用してコードを実行する方法です。 そのためには、アセンブリへのパス `dotnet path/to/an/assembly.dll` を指定します。

## <a name="migrating-your-dnx-project-to-net-core-cli"></a>DNX プロジェクトを .NET Core CLI に移行する
DNX から移行する際には、コードの操作時に新しいコマンドを使用することに加えて、重要なことが他に 3 つあります。

1. `global.json` ファイルで CLI を使用できるようにする場合は、このファイルを移行します。
2. プロジェクト ファイル (`project.json`) 自体を CLI ツールに移行します。
3. 任意の DNX API を、対応する BCL API に移行します。

### <a name="changing-the-globaljson-file"></a>global.json ファイルの変更
`global.json` ファイルは、RC1 プロジェクトと RC2 (またはそれ以降の) プロジェクトの両方に対して、ソリューション ファイルのように機能します。 .NET Core CLI (および Visual Studio) で RC1 とそれ以降のバージョンを区別するために、`"sdk": { "version" }` プロパティを使用して、RC1 のプロジェクトまたはそれ以降のプロジェクトが区別されます。 `global.json` にこのノードがまったく存在しない場合は、最新の状態であると見なされます。

`global.json` ファイルを更新するには、プロパティを削除するか、使用するツールの正確なバージョンをプロパティに設定します (次の例では、**1.0.0-preview2-003121**)。

```json
{
    "sdk": {
        "version": "1.0.0-preview2-003121"
    }
}
```

### <a name="migrating-the-project-file"></a>プロジェクト ファイルの移行

CLI と DNX は両方とも、`project.json` ファイルに基づいた同じ基本プロジェクト システムを使用しています。 プロジェクト ファイルの構文とセマンティクスはほぼ同じですが、シナリオに基づく多少の違いがあります。 スキーマの変更もあります。内容は[スキーマ ファイル](http://json.schemastore.org/project)を参照してください。

コンソール アプリケーションを作成する場合は、プロジェクト ファイルに次のスニペットを追加する必要があります。

```json
"buildOptions": {
    "emitEntryPoint": true
}
```

このスニペットは、アプリケーションのエントリ ポイントを出力するように `dotnet build` に指示し、コードが効果的に実行されるようにします。 クラス ライブラリを作成する場合、上記のセクションは省略します。 当然ながら、上記のスニペットを `project.json` ファイルに追加したら、静的なエントリ ポイントを追加する必要があります。 DNX を移行すると、DNX によって提供されていた DI サービスは利用できなくなります。したがって、`static void Main()` のように基本的な .NET のエントリ ポイントとする必要があります。

`project.json` に "コマンド" セクションがある場合は、それを削除することができます。 Entity Framework CLI コマンドなど、DNU コマンドとして存在していたコマンドの一部は、プロジェクトごとの拡張機能となるように CLI に移植されます。 プロジェクトで使用する独自のコマンドをビルドした場合は、それらのコマンドを CLI の拡張機能に置き換える必要があります。 この場合、`project.json` 内の `commands` ノードを `tools` ノードに置き換え、ツールの依存関係を一覧する必要があります。

これらの処理が完了したら、アプリにどのような種類の移植性を持たせるかを決める必要があります。 .NET Core では、幅広い移植性オプションを用意し、その中から選択できるようにすることに力を注ぎました。 たとえば、完全に*移植可能な*アプリケーションが必要な場合もあれば、*自己完結型* アプリケーションが必要な場合もあります。 移植可能なアプリケーションの方は .NET Framework アプリケーションの動作によく似ています。対象のコンピューター上でアプリケーションを実行するには共有コンポーネント (.NET Core) が必要です。 自己完結型アプリケーションの場合は、.NET Core を対象のコンピューターにインストールする必要はありませんが、サポートする OS ごとにアプリケーションを 1 つずつ作成する必要があります。 このような移植性の種類と詳細情報については、[アプリケーションの移植性の種類](../deploying/index.md)に関するページを参照してください。

目的の移植性の種類に対して呼び出しを行ったら、対象となるフレームワークを変更する必要があります。 .NET Core 用のアプリケーションを作成していた場合、対象となるフレームワークとして `dnxcore50` を使用していた可能性が最も高くなります。 CLI の場合、新しい [.NET Standard](../../standard/net-standard.md) によってもたらされた変更点があるので、フレームワークを次のいずれかに設定する必要があります。

1. `netcoreapp1.0`- .NET Core でアプリケーションを作成する場合 (ASP.NET Core アプリケーションを含む)
2. `netstandard1.6`- .NET Core 用のクラス ライブラリを作成する場合

その他の `dnx` の対象 (`dnx451` など) を使用する場合も、それらを変更する必要があります。 `dnx451` は、`net451` に変更する必要があります。
詳細については、「[.NET Standard](../../standard/net-standard.md)」のトピックをご覧ください。

これで、`project.json` は、ほぼ準備ができました。 特に ASP.NET Core の依存関係を使用している場合は、依存関係の一覧を確認し、依存関係を新しいバージョンに更新する必要があります。 BCL API 用に個別のパッケージを使用していた場合は、[アプリケーションの移植性の種類](../deploying/index.md)に関するページの説明に従って、ランタイム パッケージを使用することができます。

準備ができたら、`dotnet restore` を使用して復元を試みることができます ([注記参照](#dotnet-restore-note))。 依存関係のバージョンによっては、上記の対象となるフレームワークのいずれかの依存関係を NuGet が解決できない場合にエラーが発生する可能性があります。 これは "ポイント イン タイム" 問題です。時間の経過と共に、これらのフレームワークのサポートを含むパッケージが増える現象です。 今のところ、このエラーが発生した場合は、`framework` ノード内に `imports` ステートメントを使用して、"imports" ステートメント内のフレームワークを対象とするパッケージを復元できるという条件を NuGet に示すことができます。
この場合に返される復元エラーに含まれる情報を見れば、どのフレームワークをインポートすればよいかを特定できるはずです。 情報が不足している場合、または、まだ慣れていない場合は、通常、`dnxcore50` と `portable-net45+win8` を `imports` ステートメントに指定することで、うまくいくはずです。 次の JSON スニペットに、例を示します。

```json
    "frameworks": {
        "netcoreapp1.0": {
            "imports": ["dnxcore50", "portable-net45+win8"]
        }
    }
```

`dotnet build` を実行した場合、数がそんなに多くなくても、最終的にビルド エラーが表示されます。 コードが構築され正常に動作したら、ランナーを使用して試してみることができます。 `dotnet <path-to-your-assembly>` を実行し、それが実行されているのを確認してください。

<a name="dotnet-restore-note"></a>

[!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]
