---
title: 式ツリーの説明
description: 式ツリーについて、また、外部実行のためのアルゴリズム変換と実行前のコード検査で式ツリーがいかに役立つかについて説明します。
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036993"
---
# <a name="expression-trees-explained"></a>式ツリーの説明

[前回 -- 概要](expression-trees.md)

式ツリーはコードを定義するデータ構造です。 式ツリーは、コードの分析とコンパイル済み出力の生成にコンパイラが使用する構造と同じ構造に基づいています。 このチュートリアルを読むと、式ツリーと、[Analyzers と CodeFixes](https://github.com/dotnet/roslyn-analyzers) の構築に Roslyn API で使用される型が似ている点が多くあることがわかります
(Analyzers と CodeFixes は、コードに対して静的分析を実行し、開発者に修正案を示す機能がある NuGet パッケージです)。概念が似ており、最終的に、わかりやすい方法でソース コードを調査できるデータ構造になります。 ただし、式ツリーは Roslyn API とまったく異なるクラスと API のセットに基づいています。

単純な例を見てみましょう。
次のコードがあります。

```csharp
var sum = 1 + 2;
```

この式ツリーを分析すると、ツリーにはいくつかのノードが含まれています。
最も外側のノードは、代入 (`var sum = 1 + 2;`) ありの変数宣言ステートメントです。この最も外側のノードには、いくつかの子ノードが含まれています。変数の宣言、代入演算子、そして等号の右側を表す式です。 この式は、さらに加算演算と加算の左右のオペランドを表す式に分割されます。

等号の右側を構成する式を詳しく見てみましょう。
式は `1 + 2` です。 これは二項式です。 具体的には、二項加算式です。 二項加算式には、加算式の左ノードと右ノードを表す 2 つの子があります。 ここで、いずれのノードも定数式です。左オペランドは値 `1`、右オペランドは値 `2` です。

見た目では、ステートメント全体が 1 つのツリーです。ルート ノードから始めて、ツリーの各ノードをたどり、ステートメントを構成するコードを確認することができます。

- 代入 (`var sum = 1 + 2;`) ありの変数宣言ステートメント
  - 暗黙的な変数の型宣言 (`var sum`)
    - 暗黙的な var キーワード (`var`)
    - 変数名の宣言 (`sum`)
  - 代入演算子 (`=`)
  - 二項加算式 (`1 + 2`)
    - 左オペランド (`1`)
    - 加算演算子 (`+`)
    - 右オペランド (`2`)

これは複雑に見えるかもしれませんが、とても強力です。 同じプロセスに従って、はるかに複雑な式を分解することができます。 次の式について考えます。

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

上の式も、代入ありの変数宣言です。
この例では、代入の右側はとても複雑なツリーです。
ここではこの式を分解しませんが、どのようなノードがあるかを考えてみてください。 現在のオブジェクトをレシーバーとして使用するメソッド呼び出しがあります。1 つは明示的な `this` レシーバーを持つものと、もう 1 つは持たないものです。 他のレシーバー オブジェクトを使用するメソッド呼び出しがあり、さまざまな型の定数の引数があります。 最後に、二項加算演算子があります。 `SecretSauceFunction()` または `MoreSecretSauce()` の戻り値の型にもよりますが、二項加算演算子がオーバーライドされた加算演算子のメソッド呼び出しになり、静的メソッド呼び出しがクラスに定義されている二項加算演算子に解決されることがあります。

このような複雑さはありますが、上の式では、最初のサンプルと同じくらい簡単にたどることができるツリー構造が作成されます。 子ノードをたどっていくと、式内のリーフ ノードを見つけることができます。 親ノードには子への参照があり、各ノードにはノードの種類を説明するプロパティがあります。

式ツリーの構造には高い一貫性があります。 基本がわかると、非常に複雑なコードが式ツリーとして表された場合でも理解できるようになります。 データ構造が洗練されているので、C# コンパイラが非常に複雑な C# プログラムをどのように分析し、複雑なソース コードから正しい出力を生成できるかがわかります。

式ツリーの構造に慣れると、その身につけた知識を他の高度なシナリオにもすぐに応用できるようになります。 式ツリーには優れた機能があります。

他の環境で実行されるアルゴリズムを変換するだけでなく、式ツリーを使用してコードの実行前に調査するアルゴリズムを簡単に作成できます。 引数が式のメソッドを作成し、その式を調査してからコードを実行できます。 式ツリーは、コード全体を表したものです。任意のサブ式の値を確認できます。
メソッドとプロパティ名を確認できます。 定数式の値を確認できます。
また、式ツリーを実行可能なデリゲートに変換し、コードを実行することもできます。

式ツリーの API を使用すると、ほぼすべての有効なコード コンストラクトを表すツリーを作成できます。 ただし、可能な限り単純にするために、式ツリーでは一部の C# の表現方法を作成できません。 たとえば、(`async` および `await` キーワードを使用する) 非同期式です。 非同期アルゴリズムが必要な場合は、コンパイラのサポートに頼らず、`Task` オブジェクトを直接操作する必要があります。 もう 1 つの例は、ループの作成時です。 通常、ループの作成には `for`、`foreach`、`while`、または `do` ループを使用します。 [このシリーズの後半](expression-trees-building.md)で説明しますが、式ツリーの API は、ループの繰り返しを制御する `break` 式と `continue` 式を使用した 1 つのループ式をサポートしています。

実行できないことの 1 つが式ツリーの変更です。  式ツリーは不変のデータ構造です。 式ツリーを変更するには、元の式ツリーのコピーに変更を加えた新しいツリーを作成する必要があります。

[次へ -- 式ツリーをサポートするフレームワークの型](expression-classes.md)
