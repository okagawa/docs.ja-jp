---
title: C# のクラスとオブジェクト - C# 言語のツアー
description: C# を始めてお使いの方のために、 クラス、オブジェクト、および継承の概要を示します
ms.date: 02/27/2020
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: c178e11b5667905f75538555c8a309e2fdb4a9ef
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "78159183"
---
# <a name="classes-and-objects"></a>クラスとオブジェクト

"*クラス*" は C# の最も基本的な型です。 クラスは、状態 (フィールド) とアクション (メソッドおよびその他の関数メンバー) を 1 つの単位としてまとめたデータ構造です。 クラスは動的に作成された "*インスタンス*" の定義を提供し、"*オブジェクト*" とも呼ばれます。 クラスでは、"*継承*"と "*ポリモーフィズム*" をサポートします。これによって "*派生クラス*" が "*基底クラス*" を拡張して特殊化できます。

新しいクラスはクラス宣言を使用して作成されます。 クラス宣言は、クラスの属性と修飾子、クラスの名前、基底クラス (指定されている場合)、およびクラスによって実装されるインターフェイスを指定するヘッダーで開始します。 ヘッダーの後にはクラス本体が続きます。これは、区切り記号 `{` と `}` の間に記述するメンバー宣言のリストで構成されます。

次のコードは、`Point` という名前の単純なクラスの宣言を示しています。

[!code-csharp[PointClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

クラスのインスタンスは `new` 演算子を使用して作成されます。この演算子は新しいインスタンスのメモリを割り当て、コンストラクターを呼び出してインスタンスを初期化し、インスタンスへの参照を返します。 次のステートメントは、2 つの Point オブジェクトを作成し、それらのオブジェクトへの参照を 2 つの変数に格納します。

[!code-csharp[PointExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

オブジェクトで占有されたメモリは、そのオブジェクトに到達できなくなると自動的に解放されます。 C# では、オブジェクトの割り当てを明示的に解放する必要がなく、また解放することもできません。

## <a name="members"></a>メンバー

クラスのメンバーは、静的メンバーまたはインスタンス メンバーです。 静的メンバーはクラスに属しており、インスタンス メンバーはオブジェクト (クラスのインスタンス) に属しています。

クラスに格納できるメンバーの種類の概要を次の一覧に示します。

- 定数
  - クラスに関連付けられている定数値
- フィールド
  - クラスの変数
- メソッド
  - クラスによって実行可能な計算とアクション
- プロパティ
  - クラスの名前付きプロパティの読み取りと書き込みに関連付けられているアクション
- インデクサー
  - 配列など、クラスのインスタンスのインデックス作成に関連付けられているアクション
- イベント
  - クラスによって生成可能な通知
- 演算子
  - クラスによってサポートされている変換と式の演算子
- コンストラクター
  - クラスのインスタンスまたはクラス自体を初期化するために必要なアクション
- ファイナライザー
  - クラスのインスタンスが完全に破棄される前に実行するアクション
- 型
  - クラスで宣言される、入れ子にされた型

## <a name="accessibility"></a>ユーザー補助

クラスの各メンバーにはアクセシビリティが関連付けられています。アクセシビリティにより、メンバーへのアクセスが可能なプログラムのテキストの範囲が制御されます。 アクセシビリティには 6 つの有効な形式があります。 アクセス修飾子の概要を次に示します。

- `public`
  - アクセスは制限されません。
- `protected`
  - アクセスは、このクラスまたはこのクラスから派生したクラスに制限されます。
- `internal`
  - アクセスは、現在のアセンブリ (.exe、.dll など) に制限されます。
- `protected internal`
  - アクセスは、それを含んでいるクラス、含んでいるクラスから派生したクラス、または同じアセンブリ内のクラスに制限されます。
- `private`
  - アクセスはこのクラスに制限されます。
- `private protected`
  - アクセスは、それを含んでいるクラスまたは同じアセンブリ内のそれを含んでいる型から派生されたクラスに制限されます。

## <a name="type-parameters"></a>型パラメーター

クラス定義では、クラス名の後に型パラメーター名のリストを山かっこで囲むことで、型パラメーターのセットを指定できます。 これで、クラスのメンバーを定義するクラス宣言の本体で型パラメーターを使用できます。 次の例では、`Pair` の型パラメーターは `TFirst` と `TSecond` です。

[!code-csharp[Pair](~/samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

型パラメーターを受け取るために宣言されるクラス型は、"*ジェネリック クラス型*" と呼ばれます。 構造体、インターフェイス、およびデリゲートの型もジェネリックです。
ジェネリック クラスを使用する場合は、それぞれの型パラメーターの型引数を指定する必要があります。

[!code-csharp[PairExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

上記の `Pair<int,string>` のような、型引数が指定されたジェネリック型は "*構築された型*" と呼ばれます。

## <a name="base-classes"></a>基底クラス

クラス宣言では、クラス名と型パラメーターの後にコロンと基底クラスの名前を入力することで、基底クラスを指定できます。 基底クラスの指定の省略は、`object` 型からの派生と同じです。 次の例では、`Point3D` の基底クラスは `Point` であり、`Point` の基底クラスは `object` です。

[!code-csharp[Point3DClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

クラスは、その基底クラスのメンバーを継承します。 継承では、インスタンス、静的コンストラクター、および基底クラスのファイナライザーを除く、基底クラスのすべてのメンバーがクラスに暗黙的に含まれています。 派生クラスでは、継承するメンバーに新しいメンバーを追加できますが、継承されたメンバーの定義を削除することはできません。 前述の例では、`Point3D` は、`Point` から `x` フィールドと `y` フィールドを継承します。各 `Point3D` インスタンスには、`x`、`y`、`z` の 3 つのフィールドが含まれています。

暗黙的な変換は、クラス型からその基底クラス型のいずれかに存在します。 クラス型の変数は、そのクラスのインスタンスまたは任意の派生クラスのインスタンスを参照できます。 たとえば、前述のクラス宣言では、`Point` 型の変数が `Point` または `Point3D` を参照できます。

[!code-csharp[Point3DExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a>フィールド

"*フィールド*" は、クラスまたはクラスのインスタンスに関連付けられている変数です。

static 修飾子で宣言されているフィールドは、静的フィールドを定義します。 静的フィールドは、格納場所を 1 つだけ識別します。 クラスのインスタンスがいくつ作成されても、静的フィールドのコピーは 1 つだけです。

static 修飾子なしで宣言されているフィールドは、インスタンス フィールドを定義します。 クラスの各インスタンスには、そのクラスのすべてのインスタンス フィールドの個別のコピーが含まれています。

次の例では、`Color` クラスの各インスタンスに、インスタンス フィールド `r`、`g`、`b` の個別のコピーが含まれていますが、静的フィールド `Black`、`White`、`Red`、`Green`、`Blue` のコピーは 1 つだけです。

[!code-csharp[ColorClass](~/samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

前述の例のように、`readonly` 修飾子を使用して "*読み取り専用フィールド*" を宣言できます。 `readonly` フィールドへの割り当ては、フィールドの宣言の一部として、または同じクラスのコンストラクター内でのみ可能です。

## <a name="methods"></a>メソッド

"*メソッド*" は、オブジェクトまたはクラスによって実行可能な計算またはアクションを実装するメンバーです。 "*静的メソッド*" にはクラスを通じてアクセスします。 "*インスタンス メソッド*" にはクラスのインスタンスを通じてアクセスします。

メソッドには、"*パラメーター*" のリスト (パラメーターは、メソッドに渡される値または変数参照を表します) と "*戻り値の型*" (メソッドによって計算されて返される値の型を指定します) を含めることができます。 メソッドによって値が返されない場合、メソッドの戻り値の型は `void` です。

型と同様に、メソッドには型パラメーターのセットを含めることができます。その場合、メソッドの呼び出し時に型引数を指定する必要があります。 型引数は、型とは異なり、多くの場合メソッド呼び出しの引数から推論できます。型引数を明示的に指定する必要はありません。

メソッドの "*シグネチャ*" は、メソッドが宣言されているクラス内で一意である必要があります。 メソッドのシグネチャは、メソッドの名前、型パラメーターの数、およびメソッドのパラメーターの数、修飾子、型で構成されます。 メソッドのシグネチャに戻り値の型は含まれません。

### <a name="parameters"></a>パラメーター

パラメーターは、値または変数参照をメソッドに渡すために使用されます。 メソッドのパラメーターは、メソッドの呼び出し時に指定する "*引数*" から実際の値を取得します。 値パラメーター、参照パラメーター、出力パラメーター、およびパラメーター配列の 4 種類のパラメーターがあります。

"*値パラメーター*" は、入力引数を渡すために使われます。 値パラメーターは、パラメーターに渡された引数からその初期値を取得するローカル変数に相当します。 値パラメーターに対する変更は、パラメーターに渡された引数には影響を与えません。

値パラメーターは省略可能であり、既定値を指定すると、対応する引数を省略できます。

"*参照パラメーター*" は、参照によって引数を渡すために使われます。 参照パラメーターに渡す引数は確定値を持つ変数である必要があり、メソッドが実行している間、参照パラメーターは引数の変数と同じ格納場所を表します。 参照パラメーターは、`ref` 修飾子で宣言されます。 `ref` パラメーターの使用例を次に示します。

[!code-csharp[swapExample](~/samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

"*出力パラメーター*" は、参照によって引数を渡すために使われます。 参照パラメーターに似ていますが、呼び出し元が提供する引数に値を明示的に割り当てる必要がない点が異なります。 出力パラメーターは、`out` 修飾子で宣言されます。 次の例では、C# 7 で導入された構文を使っている `out` パラメーターを示します。

[!code-csharp[OutExample](~/samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

"*パラメーター配列*" は、引数の変数の数をメソッドに渡せるようにします。 パラメーター配列は、`params` 修飾子で宣言されます。 パラメーター配列として使用できるのは、メソッドの最後のパラメーターのみです。パラメーター配列の型は、1 次元配列の型である必要があります。 <xref:System.Console?displayProperty=nameWithType> クラスの Write メソッドと WriteLine メソッドは、パラメーター配列の使用方法を示す良い例です。 これらのメソッドは次のように宣言されます。

[!code-csharp[ConsoleExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

パラメーター配列を使用するメソッド内では、パラメーター配列は、配列型の通常のパラメーターとまったく同じように動作します。 ただし、パラメーター配列を使用するメソッドの呼び出しでは、パラメーター配列の型の 1 つの引数またはパラメーター配列の要素型の任意の数の引数を渡すことができます。 後者の場合、配列インスタンスが自動的に作成され、指定した引数を使用して初期化されます。 次のような例があるとします。

[!code-csharp[StringFormat](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

これは、次の記述と同じです。

[!code-csharp[StringFormat2](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a>メソッドの本体とローカル変数

メソッドの本体では、メソッドの呼び出し時に実行するステートメントを指定します。

メソッドの本体は、メソッドの呼び出しに固有の変数を宣言できます。 このような変数は "*ローカル変数*" と呼ばれます。 ローカル変数宣言は、型名、変数名、および (場合によっては) 初期値を指定します。 次の例では、初期値 0 を使用してローカル変数 `i` を宣言し、初期値を使用せずにローカル変数 `j` を宣言します。

[!code-csharp[Squares](~/samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

C# では、ローカル変数の値を取得する前に、ローカル変数を "*明示的に割り当てる*" 必要があります。 たとえば、前述の `i` の宣言に初期値が含まれていなかった場合、コンパイラによって以降の `i` の使用に対するエラーが報告されます。これは、プログラム内のそれらのポイントで `i` が明示的に割り当てられていないためです。

メソッドでは、`return` ステートメントを使用して、呼び出し元に制御を戻すことができます。 `void` を返すメソッドの場合、`return` ステートメントでは式を指定できません。 void 以外を返すメソッドの場合、`return` ステートメントは戻り値を計算する式を含める必要があります。

### <a name="static-and-instance-methods"></a>静的メソッドとインスタンス メソッド

static 修飾子で宣言されているメソッドは "*静的メソッド*" です。 静的メソッドは、特定のインスタンスでは動作せず、静的メンバーにのみ直接アクセスできます。

static 修飾子なしで宣言されているメソッドは "*インスタンス メソッド*" です。 インスタンス メソッドは、特定のインスタンスで動作し、静的メンバーとインスタンス メンバーの両方にアクセスできます。 インスタンス メソッドが呼び出されたインスタンスには、`this` として明示的にアクセスできます。 静的メソッドで `this` を参照するとエラーになります。

次の `Entity` クラスには、静的メンバーとインスタンス メンバーの両方があります。

[!code-csharp[Entity](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

各 `Entity` インスタンスには、シリアル番号 (およびここに表示されていないその他の情報) が含まれています。 `Entity` コンストラクターは (インスタンス メソッドと同様に)、次に使用可能なシリアル番号を持つ新しいインスタンスを初期化します。 コンストラクターはインスタンス メンバーであるため、`serialNo` インスタンス フィールドと `nextSerialNo` 静的フィールドの両方にアクセスできます。

静的メソッドである `GetNextSerialNo` と `SetNextSerialNo` は `nextSerialNo` 静的フィールドにアクセスできますが、`serialNo` インスタンス フィールドに直接アクセスするとエラーになります。

Entity クラスの使用例を次に示します。

[!code-csharp[EntityExample](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

静的メソッドである `SetNextSerialNo` と `GetNextSerialNo` はクラスで呼び出されますが、`GetSerialNo` インスタンス メソッドはクラスのインスタンスで呼び出されます。

### <a name="virtual-override-and-abstract-methods"></a>仮想メソッド、オーバーライド メソッド、および抽象メソッド

インスタンス メソッドの宣言に `virtual` 修飾子が含まれている場合、そのメソッドは "*仮想メソッド*" と呼ばれます。 virtual 修飾子が存在しない場合、そのメソッドは "*非仮想メソッド*" と呼ばれます。

仮想メソッドが呼び出されると、その呼び出しが行われるインスタンスの "*実行時の型*" によって、呼び出す実際のメソッドの実装が決定します。 非仮想メソッドの呼び出しでは、インスタンスの "*コンパイル時の型*" が決定要因です。

仮想メソッドは派生クラスで "*オーバーライド*" できます。 インスタンス メソッドの宣言に override 修飾子が含まれている場合、メソッドは、同じシグネチャを持つ継承された仮想メソッドをオーバーライドします。 仮想メソッドの宣言には新しいメソッドが導入されていますが、オーバーライド メソッドの宣言では、そのメソッドの新しい実装を提供することで既存の継承された仮想メソッドを特殊化します。

"*抽象メソッド*" は、実装のない仮想メソッドです。 抽象メソッドは、abstract 修飾子で宣言され、抽象として宣言されるクラスでのみ許可されます。 抽象メソッドは、すべての非抽象派生クラスでオーバーライドする必要があります。

次の例では、式ツリー ノードを表す抽象クラス `Expression`、および定数、変数参照、算術演算の式ツリー ノードを実装する 3 つの派生クラス `Constant`、`VariableReference`、`Operation` を宣言します (この例は式ツリー型に似ていますが、混同しないようにしてください)。

[!code-csharp[ExpressionClass](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

前述の 4 つのクラスは、算術式をモデル化するために使用できます。 たとえば、これらのクラスのインスタンスを使用して、式 `x + 3` を次のように表すことができます。

[!code-csharp[ExpressionExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

`Expression` インスタンスの `Evaluate` メソッドが呼び出され、指定された式を評価して `double` 値を生成します。 このメソッドは、変数の名前 (エントリのキーとして) と値 (エントリの値として) が格納されている `Dictionary` 引数を受け取ります。 `Evaluate` は抽象メソッドなので、`Expression` から派生した非抽象クラスでは、`Evaluate` をオーバーライドする必要があります。

`Evaluate` の `Constant` の実装は、格納された定数を単に返します。 `VariableReference` の実装は、ディクショナリで変数名を検索し、結果の値を返します。 `Operation` の実装は、(`Evaluate` メソッドを再帰的に呼び出すことによって) まず左と右のオペランドを評価し、指定された算術演算を実行します。

次のプログラムでは、`Expression` クラスを使用して、式 `x * (y + 2)` の異なる値の `x` と `y` を評価します。

[!code-csharp[ExpressionUsage](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a>メソッドのオーバーロード

メソッドの "*オーバーロード*" では、メソッドのシグネチャが一意であれば、同じクラス内の複数のメソッドに同じ名前を付けることができます。 オーバーロードされたメソッドの呼び出しをコンパイルする場合、コンパイラは "*オーバーロードの解決*" を使用して、呼び出すメソッドを決定します。 オーバーロードの解決では、引数に最も一致する 1 つのメソッドが特定されます。最も一致するメソッドが見つからない場合は、エラーが報告されます。 次の例は、オーバーロードの解決が有効な場合を示しています。 `UsageExample` メソッド内の各呼び出しのコメントは、呼び出されるメソッドを示しています。

[!code-csharp[OverloadUsage](~/samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

この例に示すように、パラメーターの厳密な型に引数を明示的にキャストするか、または型引数を明示的に指定することにより、特定のメソッドを常に選択できます。

## <a name="other-function-members"></a>その他の関数メンバー

実行可能コードが含まれるメンバーは、クラスの "*関数メンバー*" と総称されます。 前のセクションでは、関数メンバーの主な種類であるメソッドについて説明しました。 ここでは、C# でサポートされるその他の種類の関数メンバー (コンストラクター、プロパティ、インデクサー、イベント、演算子、およびファイナライザー) について説明します。

次の例では、オブジェクトの拡張可能なリストを実装する、`MyList<T>` と呼ばれるジェネリック クラスを示します。 このクラスには、最も一般的な種類の関数メンバーの例がいくつか含まれています。

> [!NOTE]
> この例では `MyList` クラスが作成されますが、これは .NET Standard の <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> とは異なります。 このツアーに必要な概念を示していますが、そのクラスの代わりにはなりません。

[!code-csharp[ListClass](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a>コンストラクター

C# は、インスタンス コンストラクターと静的コンストラクターの両方をサポートします。 "*インスタンス コンストラクター*" は、クラスのインスタンスを初期化するために必要なアクションを実装するメンバーです。 "*静的コンストラクター*" は、クラスを最初に読み込むときに、そのクラス自体を初期化するために必要なアクションを実装するメンバーです。

コンストラクターは、戻り値の型がなく、含んでいるクラスと同じ名前を持つメソッドのように宣言されます。 コンストラクターの宣言に static 修飾子が含まれている場合は、静的コンストラクターが宣言されます。 それ以外の場合は、インスタンス コンストラクターが宣言されます。

インスタンス コンストラクターはオーバーロード可能であり、省略可能なパラメーターを指定できます。 たとえば、`MyList<T>` クラスでは、1 つの省略可能な `int` パラメータ―を伴う 1 つのインスタンス コンストラクターを宣言します。 インスタンス コンストラクターは、`new` 演算子を使用して呼び出されます。 次のステートメントは、`MyList` クラスのコンストラクターを使用して、2 つの `MyList<string>` インスタンスを割り当てます (省略可能な引数を使用した場合と使用していない場合の両方を示します)。

[!code-csharp[ListExample1](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

他のメンバーとは異なり、インスタンス コンストラクターは継承されず、クラスには、そのクラスで実際に宣言されたコンストラクター以外のインスタンス コンストラクターがありません。 クラスのインスタンス コンストラクターが指定されていない場合は、パラメーターなしの空のコンストラクターが自動的に指定されます。

### <a name="properties"></a>プロパティ

"*プロパティ*" は、フィールドが自然に拡張したものです。 フィールドとプロパティはどちらも型が関連付けられている名前付きのメンバーであり、それらにアクセスするための構文は同じです。 ただし、フィールドとは異なり、プロパティは格納場所を表しません。 その代わりに、プロパティには、値の読み取りまたは書き込みの際に実行されるステートメントを指定する "*アクセサー*" があります。

プロパティはフィールドのように宣言されますが、宣言はセミコロンで終わるのではなく、区切り記号 `{` と `}` の間に記述する get アクセサーまたは set アクセサーで終わる点が異なります。 get アクセサーと set アクセサーの両方を持つプロパティは "*読み取り/書き込みプロパティ*"、get アクセサーだけを持つプロパティは "*読み取り専用プロパティ*"、set アクセサーだけを持つプロパティは "*書き込み専用プロパティ*" です。

get アクセサーは、プロパティの型の戻り値を持つパラメーターなしのメソッドに相当します。 プロパティが式で参照される場合 (割り当ての対象として参照される場合を除く) は、プロパティの値を計算するためにプロパティの get アクセサーが呼び出されます。

set アクセサーは、1 つのパラメーターの名前付きの値を持ち、戻り値の型を持たないメソッドに相当します。 プロパティが割り当ての対象として、または ++ あるいは -- のオペランドとして参照される場合は、新しい値を指定する引数と共に set アクセサーが呼び出されます。

`MyList<T>` クラスは 2 つのプロパティ (`Count` と `Capacity`) を宣言します。これらは、それぞれ読み取り専用プロパティと読み取り/書き込みプロパティです。 次のコードは、これらのプロパティの使用例です。

[!code-csharp[ListExample2](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

フィールドおよびメソッドと同様に、C# はインスタンス プロパティと静的プロパティの両方をサポートします。 静的プロパティは static 修飾子で宣言され、インスタンス プロパティは修飾子なしで宣言されます。

プロパティのアクセサーは仮想にすることができます。 プロパティの宣言に `virtual`、`abstract`、または `override` の各修飾子が含まれている場合、その宣言はプロパティのアクセサーに適用されます。

### <a name="indexers"></a>インデクサー

"*インデクサー*" は、配列と同じ方法でオブジェクトのインデックスを作成できるようにするメンバーです。 インデクサーはプロパティのように宣言されますが、メンバーの名前が、`this` の後に区切り記号 `[` と `]` でパラメーター リストを囲んだものになる点が異なります。 パラメーターは、インデクサーのアクセサーで使用できます。 プロパティと同様に、読み取り/書き込み、読み取り専用、および書き込み専用のインデクサーを使用できます。また、インデクサーのアクセサーを仮想にすることができます。

`MyList<T>` クラスは、`int` パラメーターを受け取る 1 つの読み取り/書き込みインデクサーを宣言します。 インデクサーを使用すると、`int` 値を持つ `MyList<T>` インスタンスのインデックスを作成できます。 次に例を示します。

[!code-csharp[ListExample3](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

インデクサーはオーバーロードできます。つまり、パラメーターの数または型が異なる限り、クラスは複数のインデクサーを宣言できます。

### <a name="events"></a>イベント

"*イベント*" は、クラスまたはオブジェクトで通知を提供できるようにするメンバーです。 イベントはフィールドのように宣言されますが、イベント キーワードが宣言に含まれており、型がデリゲート型でなければならない点が異なります。

イベント メンバーを宣言するクラス内では、イベントはデリゲート型のフィールドと同じように動作します (イベントが抽象イベントでなく、アクセサーを宣言しない場合)。 フィールドは、イベントに追加されたイベント ハンドラーを表すデリゲートへの参照を格納します。 イベント ハンドラーが存在しない場合、フィールドは `null` です。

`MyList<T>` クラスは、`Changed` という 1 つのイベント メンバーを宣言します。このメンバーは新しい項目がリストに追加されたことを示します。 Changed イベントは `OnChanged` 仮想メソッドによって発生します。このメソッドは、最初にイベントが `null` であるかどうか (ハンドラーが存在しないこと) を確認します。 イベントを発生させるという概念は、イベントによって表されるデリゲートの呼び出しとまったく同じです。したがって、イベントを発生させるための特殊な言語コンストラクトはありません。

クライアントは、"*イベント ハンドラー*" を使用してイベントに対応します。 イベント ハンドラーは、`+=` 演算子を使用してアタッチされ、`-=` 演算子を使用して削除されます。 次の例では、`MyList<string>` の `Changed` イベントにイベント ハンドラーをアタッチします。

[!code-csharp[EventExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

イベントの基になる記憶域の制御が求められる高度なシナリオでは、イベントの宣言で `add` アクセサーと `remove` アクセサーを明示的に指定できます。これらは、プロパティの `set` アクセサーに似ています。

### <a name="operators"></a>演算子

"*演算子*" は、クラスのインスタンスに特定の式の演算子を適用する意味を定義するメンバーです。 単項演算子、2 項演算子、および変換演算子の 3 種類を定義できます。 すべての演算子は `public` および `static` として宣言する必要があります。

`MyList<T>` クラスは 2 つの演算子 (`operator ==` と `operator !=`) を宣言し、`MyList` インスタンスにこれらの演算子を適用する式に新しい意味を持たせます。 具体的には、Equals メソッドを使用して含まれている各オブジェクトを比較する際に、演算子が 2 つの `MyList<T>` インスタンスの等価性を定義します。 次の例では、`==` 演算子を使用して 2 つの `MyList<int>` インスタンスを比較します。

[!code-csharp[OperatorExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

最初の `Console.WriteLine` は `True` を出力します。これは、2 つのリストに、同じ値を持つ同じ数のオブジェクトが同じ順序で含まれているためです。 `MyList<T>` で `operator ==` が定義されていない場合は、`a` と `b` が異なる `MyList<int>` インスタンスを参照するため、最初の `Console.WriteLine` は `False` を出力します。

### <a name="finalizers"></a>ファイナライザー

"*ファイナライザー*" は、クラスのインスタンスを最終処理するために必要なアクションを実装するメンバーです。 ファイナライザーではパラメーターとアクセシビリティ修飾子を使用できません。また、ファイナライザーを明示的に呼び出すことはできません。 インスタンスのファイナライザーは、ガベージ コレクション中に自動的に呼び出されます。

ガベージ コレクターは、オブジェクトを収集してファイナライザーを実行するタイミングを決定する際に広く許容されます。 具体的には、ファイナライザーの呼び出しのタイミングは確定的ではなく、ファイナライザーは任意のスレッドで実行される可能性があります。 これらの理由およびそれ以外の理由のため、他のソリューションが実現できない場合にのみ、クラスはファイナライザーを実装する必要があります。

`using` ステートメントは、オブジェクトを破棄するためのより適切な方法を提供します。

> [!div class="step-by-step"]
> [前へ](statements.md)
> [次へ](arrays.md)
