---
title: デリゲートの概要
description: この概要トピックでは、基本的な概念を紹介し、デリゲートの言語上の設計目標について説明します。
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 59b61d77-84e5-457b-8da5-fb5f24ca6ed6
ms.openlocfilehash: fd594f77c034533a1d5aee1d8279e9b727284311
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/14/2020
ms.locfileid: "79146230"
---
# <a name="introduction-to-delegates"></a>デリゲートの概要

デリゲートは、.NET における "*遅延バインディング*" のメカニズムです。 遅延バインディングとは、皆さんが作成するアルゴリズムについて、その一部を実装するメソッドを呼び出し元からも少なくとも 1 つ与えることを意味します。

たとえば天文学アプリケーションで、一連の星を並べ替えることを考えてみましょう。
星の並べ替え基準には、地球からの距離や星の等級、知覚的な明るさを選ぶことができます。

いずれの場合も、Sort() メソッドが行うことは基本的に同じです。つまり何らかの比較に基づいて一連の項目を整列します。 しかし、2 つの星を比較するコードは、並べ替えの基準によって異なります。

ソフトウェアには、この種の手法が半世紀にわたって使用されてきました。
C# 言語のデリゲートの概念は、きわめて優れた言語機能と、その概念を中心にしたタイプ セーフ機能を実現します。

本シリーズの中で後述しているように、このようなアルゴリズム向けに記述された C# コードはタイプ セーフであり、引数や戻り値の型については、言語とコンパイラの機能を利用して型の一致が保証されます。

## <a name="language-design-goals-for-delegates"></a>デリゲートの言語上の設計目標

最終的にデリゲートとなる機能を実現するにあたって、言語の設計者たちはさまざまな目標を設定しました。

設計チームが目指したのは、あらゆる遅延バインディング アルゴリズムに適用できる共通の言語概念です。 つまり、開発者が 1 つの概念を身に付ければ、ソフトウェアに関するさまざまな課題にその知識を応用できるような言語の実現を目標に掲げたのです。

次に設計チームが目指したのは、シングルキャストとマルチキャストの両方のメソッド呼び出しをサポートすることでした。 (マルチキャスト デリゲートは、複数のメソッド呼び出しを連結するデリゲートです。
[このシリーズの後の記事](delegate-class.md)で例を見ます。)

設計チームは、C# のあらゆるコード要素に関して開発者たちが当然と考えるレベルのタイプ セーフティをデリゲートにおいても実現したいと考えていたのです。

また、設計チームは、デリゲートを初めとする遅延バインディング アルゴリズムの利便性が大いに発揮される具体的なパターンは、イベント パターンであると認識していました。 .NET のイベントの基本的なパターンをデリゲートのコードで確実に実現したいと考えていたのです。

そうした目標に向けたすべての作業の成果として C# と .NET にサポートされたのが、デリゲートとイベントです。 以降このセクションの記事では、言語の機能やライブラリのサポート、デリゲートを扱う際に用いられる一般的な用語について取り上げています。

`delegate` キーワードとそれによって生成されるコード、 `System.Delegate` クラスの機能とその使い方、 タイプ セーフなデリゲートの作成方法、デリゲート経由で呼び出すことのできるメソッドの作成方法のほか、 ラムダ式を使ったデリゲートやイベントの扱い方、 LINQ の構成要素としてデリゲートがどこで使われているか、 .NET のイベント パターンの基礎としてデリゲートがどのように使われ、両者がどのように違うのかについても説明します。

すべての記事を読み終えると、.NET のプログラミングやフレームワーク API を利用するうえでの不可欠な要素として、デリゲートがどのように活かされているのかがおわかりいただけると思います。

それでは始めましょう。

[次へ](delegate-class.md)
